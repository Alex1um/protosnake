// This file is generated by rust-protobuf 3.2.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `src/snakes.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_2_0;

///  Игрок
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:snakes.GamePlayer)
pub struct GamePlayer {
    // message fields
    // @@protoc_insertion_point(field:snakes.GamePlayer.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:snakes.GamePlayer.id)
    pub id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:snakes.GamePlayer.ip_address)
    pub ip_address: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:snakes.GamePlayer.port)
    pub port: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:snakes.GamePlayer.role)
    pub role: ::std::option::Option<::protobuf::EnumOrUnknown<NodeRole>>,
    // @@protoc_insertion_point(field:snakes.GamePlayer.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<PlayerType>>,
    // @@protoc_insertion_point(field:snakes.GamePlayer.score)
    pub score: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:snakes.GamePlayer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GamePlayer {
    fn default() -> &'a GamePlayer {
        <GamePlayer as ::protobuf::Message>::default_instance()
    }
}

impl GamePlayer {
    pub fn new() -> GamePlayer {
        ::std::default::Default::default()
    }

    // required string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required int32 id = 2;

    pub fn id(&self) -> i32 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional string ip_address = 3;

    pub fn ip_address(&self) -> &str {
        match self.ip_address.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_ip_address(&mut self) {
        self.ip_address = ::std::option::Option::None;
    }

    pub fn has_ip_address(&self) -> bool {
        self.ip_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip_address(&mut self, v: ::std::string::String) {
        self.ip_address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip_address(&mut self) -> &mut ::std::string::String {
        if self.ip_address.is_none() {
            self.ip_address = ::std::option::Option::Some(::std::string::String::new());
        }
        self.ip_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_ip_address(&mut self) -> ::std::string::String {
        self.ip_address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 port = 4;

    pub fn port(&self) -> i32 {
        self.port.unwrap_or(0)
    }

    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: i32) {
        self.port = ::std::option::Option::Some(v);
    }

    // required .snakes.NodeRole role = 5;

    pub fn role(&self) -> NodeRole {
        match self.role {
            Some(e) => e.enum_value_or(NodeRole::NORMAL),
            None => NodeRole::NORMAL,
        }
    }

    pub fn clear_role(&mut self) {
        self.role = ::std::option::Option::None;
    }

    pub fn has_role(&self) -> bool {
        self.role.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: NodeRole) {
        self.role = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .snakes.PlayerType type = 6;

    pub fn type_(&self) -> PlayerType {
        match self.type_ {
            Some(e) => e.enum_value_or(PlayerType::HUMAN),
            None => PlayerType::HUMAN,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: PlayerType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int32 score = 7;

    pub fn score(&self) -> i32 {
        self.score.unwrap_or(0)
    }

    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: i32) {
        self.score = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &GamePlayer| { &m.name },
            |m: &mut GamePlayer| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &GamePlayer| { &m.id },
            |m: &mut GamePlayer| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ip_address",
            |m: &GamePlayer| { &m.ip_address },
            |m: &mut GamePlayer| { &mut m.ip_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "port",
            |m: &GamePlayer| { &m.port },
            |m: &mut GamePlayer| { &mut m.port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "role",
            |m: &GamePlayer| { &m.role },
            |m: &mut GamePlayer| { &mut m.role },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &GamePlayer| { &m.type_ },
            |m: &mut GamePlayer| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "score",
            |m: &GamePlayer| { &m.score },
            |m: &mut GamePlayer| { &mut m.score },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GamePlayer>(
            "GamePlayer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GamePlayer {
    const NAME: &'static str = "GamePlayer";

    fn is_initialized(&self) -> bool {
        if self.name.is_none() {
            return false;
        }
        if self.id.is_none() {
            return false;
        }
        if self.role.is_none() {
            return false;
        }
        if self.score.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.id = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.ip_address = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.port = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.role = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                48 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                56 => {
                    self.score = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.ip_address.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.port {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.role {
            my_size += ::protobuf::rt::int32_size(5, v.value());
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.score {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.ip_address.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.port {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.role {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.score {
            os.write_int32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GamePlayer {
        GamePlayer::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.id = ::std::option::Option::None;
        self.ip_address = ::std::option::Option::None;
        self.port = ::std::option::Option::None;
        self.role = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.score = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GamePlayer {
        static instance: GamePlayer = GamePlayer {
            name: ::std::option::Option::None,
            id: ::std::option::Option::None,
            ip_address: ::std::option::Option::None,
            port: ::std::option::Option::None,
            role: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            score: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GamePlayer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GamePlayer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GamePlayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GamePlayer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Параметры идущей игры (не должны меняться в процессе игры) 
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:snakes.GameConfig)
pub struct GameConfig {
    // message fields
    // @@protoc_insertion_point(field:snakes.GameConfig.width)
    pub width: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:snakes.GameConfig.height)
    pub height: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:snakes.GameConfig.food_static)
    pub food_static: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:snakes.GameConfig.state_delay_ms)
    pub state_delay_ms: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:snakes.GameConfig.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GameConfig {
    fn default() -> &'a GameConfig {
        <GameConfig as ::protobuf::Message>::default_instance()
    }
}

impl GameConfig {
    pub fn new() -> GameConfig {
        ::std::default::Default::default()
    }

    // optional int32 width = 1;

    pub fn width(&self) -> i32 {
        self.width.unwrap_or(40i32)
    }

    pub fn clear_width(&mut self) {
        self.width = ::std::option::Option::None;
    }

    pub fn has_width(&self) -> bool {
        self.width.is_some()
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: i32) {
        self.width = ::std::option::Option::Some(v);
    }

    // optional int32 height = 2;

    pub fn height(&self) -> i32 {
        self.height.unwrap_or(30i32)
    }

    pub fn clear_height(&mut self) {
        self.height = ::std::option::Option::None;
    }

    pub fn has_height(&self) -> bool {
        self.height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = ::std::option::Option::Some(v);
    }

    // optional int32 food_static = 3;

    pub fn food_static(&self) -> i32 {
        self.food_static.unwrap_or(1i32)
    }

    pub fn clear_food_static(&mut self) {
        self.food_static = ::std::option::Option::None;
    }

    pub fn has_food_static(&self) -> bool {
        self.food_static.is_some()
    }

    // Param is passed by value, moved
    pub fn set_food_static(&mut self, v: i32) {
        self.food_static = ::std::option::Option::Some(v);
    }

    // optional int32 state_delay_ms = 5;

    pub fn state_delay_ms(&self) -> i32 {
        self.state_delay_ms.unwrap_or(1000i32)
    }

    pub fn clear_state_delay_ms(&mut self) {
        self.state_delay_ms = ::std::option::Option::None;
    }

    pub fn has_state_delay_ms(&self) -> bool {
        self.state_delay_ms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state_delay_ms(&mut self, v: i32) {
        self.state_delay_ms = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "width",
            |m: &GameConfig| { &m.width },
            |m: &mut GameConfig| { &mut m.width },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "height",
            |m: &GameConfig| { &m.height },
            |m: &mut GameConfig| { &mut m.height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "food_static",
            |m: &GameConfig| { &m.food_static },
            |m: &mut GameConfig| { &mut m.food_static },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "state_delay_ms",
            |m: &GameConfig| { &m.state_delay_ms },
            |m: &mut GameConfig| { &mut m.state_delay_ms },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GameConfig>(
            "GameConfig",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GameConfig {
    const NAME: &'static str = "GameConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.width = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.height = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.food_static = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.state_delay_ms = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.width {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.height {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.food_static {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.state_delay_ms {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.width {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.height {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.food_static {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.state_delay_ms {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GameConfig {
        GameConfig::new()
    }

    fn clear(&mut self) {
        self.width = ::std::option::Option::None;
        self.height = ::std::option::Option::None;
        self.food_static = ::std::option::Option::None;
        self.state_delay_ms = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GameConfig {
        static instance: GameConfig = GameConfig {
            width: ::std::option::Option::None,
            height: ::std::option::Option::None,
            food_static: ::std::option::Option::None,
            state_delay_ms: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GameConfig {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GameConfig").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GameConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GameConfig {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Игроки конкретной игры 
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:snakes.GamePlayers)
pub struct GamePlayers {
    // message fields
    // @@protoc_insertion_point(field:snakes.GamePlayers.players)
    pub players: ::std::vec::Vec<GamePlayer>,
    // special fields
    // @@protoc_insertion_point(special_field:snakes.GamePlayers.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GamePlayers {
    fn default() -> &'a GamePlayers {
        <GamePlayers as ::protobuf::Message>::default_instance()
    }
}

impl GamePlayers {
    pub fn new() -> GamePlayers {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "players",
            |m: &GamePlayers| { &m.players },
            |m: &mut GamePlayers| { &mut m.players },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GamePlayers>(
            "GamePlayers",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GamePlayers {
    const NAME: &'static str = "GamePlayers";

    fn is_initialized(&self) -> bool {
        for v in &self.players {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.players.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.players {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GamePlayers {
        GamePlayers::new()
    }

    fn clear(&mut self) {
        self.players.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GamePlayers {
        static instance: GamePlayers = GamePlayers {
            players: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GamePlayers {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GamePlayers").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GamePlayers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GamePlayers {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Текущее состояние игрового поля 
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:snakes.GameState)
pub struct GameState {
    // message fields
    // @@protoc_insertion_point(field:snakes.GameState.state_order)
    pub state_order: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:snakes.GameState.snakes)
    pub snakes: ::std::vec::Vec<game_state::Snake>,
    // @@protoc_insertion_point(field:snakes.GameState.foods)
    pub foods: ::std::vec::Vec<game_state::Coord>,
    // @@protoc_insertion_point(field:snakes.GameState.players)
    pub players: ::protobuf::MessageField<GamePlayers>,
    // special fields
    // @@protoc_insertion_point(special_field:snakes.GameState.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GameState {
    fn default() -> &'a GameState {
        <GameState as ::protobuf::Message>::default_instance()
    }
}

impl GameState {
    pub fn new() -> GameState {
        ::std::default::Default::default()
    }

    // required int32 state_order = 1;

    pub fn state_order(&self) -> i32 {
        self.state_order.unwrap_or(0)
    }

    pub fn clear_state_order(&mut self) {
        self.state_order = ::std::option::Option::None;
    }

    pub fn has_state_order(&self) -> bool {
        self.state_order.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state_order(&mut self, v: i32) {
        self.state_order = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "state_order",
            |m: &GameState| { &m.state_order },
            |m: &mut GameState| { &mut m.state_order },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "snakes",
            |m: &GameState| { &m.snakes },
            |m: &mut GameState| { &mut m.snakes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "foods",
            |m: &GameState| { &m.foods },
            |m: &mut GameState| { &mut m.foods },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GamePlayers>(
            "players",
            |m: &GameState| { &m.players },
            |m: &mut GameState| { &mut m.players },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GameState>(
            "GameState",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GameState {
    const NAME: &'static str = "GameState";

    fn is_initialized(&self) -> bool {
        if self.state_order.is_none() {
            return false;
        }
        if self.players.is_none() {
            return false;
        }
        for v in &self.snakes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.foods {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.players {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.state_order = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.snakes.push(is.read_message()?);
                },
                26 => {
                    self.foods.push(is.read_message()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.players)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.state_order {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        for value in &self.snakes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.foods {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.players.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.state_order {
            os.write_int32(1, v)?;
        }
        for v in &self.snakes {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.foods {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.players.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GameState {
        GameState::new()
    }

    fn clear(&mut self) {
        self.state_order = ::std::option::Option::None;
        self.snakes.clear();
        self.foods.clear();
        self.players.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GameState {
        static instance: GameState = GameState {
            state_order: ::std::option::Option::None,
            snakes: ::std::vec::Vec::new(),
            foods: ::std::vec::Vec::new(),
            players: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GameState {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GameState").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GameState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GameState {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `GameState`
pub mod game_state {
    ///  Координаты в пределах игрового поля, либо относительное смещение координат.
    ///  Левая верхняя клетка поля имеет координаты (x=0, y=0).
    ///  Направление смещения задаётся знаком чисел. 
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:snakes.GameState.Coord)
    pub struct Coord {
        // message fields
        // @@protoc_insertion_point(field:snakes.GameState.Coord.x)
        pub x: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:snakes.GameState.Coord.y)
        pub y: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:snakes.GameState.Coord.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Coord {
        fn default() -> &'a Coord {
            <Coord as ::protobuf::Message>::default_instance()
        }
    }

    impl Coord {
        pub fn new() -> Coord {
            ::std::default::Default::default()
        }

        // optional sint32 x = 1;

        pub fn x(&self) -> i32 {
            self.x.unwrap_or(0i32)
        }

        pub fn clear_x(&mut self) {
            self.x = ::std::option::Option::None;
        }

        pub fn has_x(&self) -> bool {
            self.x.is_some()
        }

        // Param is passed by value, moved
        pub fn set_x(&mut self, v: i32) {
            self.x = ::std::option::Option::Some(v);
        }

        // optional sint32 y = 2;

        pub fn y(&self) -> i32 {
            self.y.unwrap_or(0i32)
        }

        pub fn clear_y(&mut self) {
            self.y = ::std::option::Option::None;
        }

        pub fn has_y(&self) -> bool {
            self.y.is_some()
        }

        // Param is passed by value, moved
        pub fn set_y(&mut self, v: i32) {
            self.y = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "x",
                |m: &Coord| { &m.x },
                |m: &mut Coord| { &mut m.x },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "y",
                |m: &Coord| { &m.y },
                |m: &mut Coord| { &mut m.y },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Coord>(
                "GameState.Coord",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Coord {
        const NAME: &'static str = "Coord";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.x = ::std::option::Option::Some(is.read_sint32()?);
                    },
                    16 => {
                        self.y = ::std::option::Option::Some(is.read_sint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.x {
                my_size += ::protobuf::rt::sint32_size(1, v);
            }
            if let Some(v) = self.y {
                my_size += ::protobuf::rt::sint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.x {
                os.write_sint32(1, v)?;
            }
            if let Some(v) = self.y {
                os.write_sint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Coord {
            Coord::new()
        }

        fn clear(&mut self) {
            self.x = ::std::option::Option::None;
            self.y = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Coord {
            static instance: Coord = Coord {
                x: ::std::option::Option::None,
                y: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Coord {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("GameState.Coord").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Coord {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Coord {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    ///  Змея
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:snakes.GameState.Snake)
    pub struct Snake {
        // message fields
        // @@protoc_insertion_point(field:snakes.GameState.Snake.player_id)
        pub player_id: ::std::option::Option<i32>,
        ///  Список "ключевых" точек змеи. Первая точка хранит координаты головы змеи.
        ///  Каждая следующая - смещение следующей "ключевой" точки относительно предыдущей,
        ///  в частности последняя точка хранит смещение хвоста змеи относительно предыдущей "ключевой" точки. 
        // @@protoc_insertion_point(field:snakes.GameState.Snake.points)
        pub points: ::std::vec::Vec<Coord>,
        // @@protoc_insertion_point(field:snakes.GameState.Snake.state)
        pub state: ::std::option::Option<::protobuf::EnumOrUnknown<snake::SnakeState>>,
        // @@protoc_insertion_point(field:snakes.GameState.Snake.head_direction)
        pub head_direction: ::std::option::Option<::protobuf::EnumOrUnknown<super::Direction>>,
        // special fields
        // @@protoc_insertion_point(special_field:snakes.GameState.Snake.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Snake {
        fn default() -> &'a Snake {
            <Snake as ::protobuf::Message>::default_instance()
        }
    }

    impl Snake {
        pub fn new() -> Snake {
            ::std::default::Default::default()
        }

        // required int32 player_id = 1;

        pub fn player_id(&self) -> i32 {
            self.player_id.unwrap_or(0)
        }

        pub fn clear_player_id(&mut self) {
            self.player_id = ::std::option::Option::None;
        }

        pub fn has_player_id(&self) -> bool {
            self.player_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_id(&mut self, v: i32) {
            self.player_id = ::std::option::Option::Some(v);
        }

        // required .snakes.GameState.Snake.SnakeState state = 3;

        pub fn state(&self) -> snake::SnakeState {
            match self.state {
                Some(e) => e.enum_value_or(snake::SnakeState::ALIVE),
                None => snake::SnakeState::ALIVE,
            }
        }

        pub fn clear_state(&mut self) {
            self.state = ::std::option::Option::None;
        }

        pub fn has_state(&self) -> bool {
            self.state.is_some()
        }

        // Param is passed by value, moved
        pub fn set_state(&mut self, v: snake::SnakeState) {
            self.state = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // required .snakes.Direction head_direction = 4;

        pub fn head_direction(&self) -> super::Direction {
            match self.head_direction {
                Some(e) => e.enum_value_or(super::Direction::UP),
                None => super::Direction::UP,
            }
        }

        pub fn clear_head_direction(&mut self) {
            self.head_direction = ::std::option::Option::None;
        }

        pub fn has_head_direction(&self) -> bool {
            self.head_direction.is_some()
        }

        // Param is passed by value, moved
        pub fn set_head_direction(&mut self, v: super::Direction) {
            self.head_direction = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "player_id",
                |m: &Snake| { &m.player_id },
                |m: &mut Snake| { &mut m.player_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "points",
                |m: &Snake| { &m.points },
                |m: &mut Snake| { &mut m.points },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "state",
                |m: &Snake| { &m.state },
                |m: &mut Snake| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "head_direction",
                |m: &Snake| { &m.head_direction },
                |m: &mut Snake| { &mut m.head_direction },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Snake>(
                "GameState.Snake",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Snake {
        const NAME: &'static str = "Snake";

        fn is_initialized(&self) -> bool {
            if self.player_id.is_none() {
                return false;
            }
            if self.state.is_none() {
                return false;
            }
            if self.head_direction.is_none() {
                return false;
            }
            for v in &self.points {
                if !v.is_initialized() {
                    return false;
                }
            };
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.player_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.points.push(is.read_message()?);
                    },
                    24 => {
                        self.state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    32 => {
                        self.head_direction = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.player_id {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            for value in &self.points {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.state {
                my_size += ::protobuf::rt::int32_size(3, v.value());
            }
            if let Some(v) = self.head_direction {
                my_size += ::protobuf::rt::int32_size(4, v.value());
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.player_id {
                os.write_int32(1, v)?;
            }
            for v in &self.points {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            if let Some(v) = self.state {
                os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.head_direction {
                os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Snake {
            Snake::new()
        }

        fn clear(&mut self) {
            self.player_id = ::std::option::Option::None;
            self.points.clear();
            self.state = ::std::option::Option::None;
            self.head_direction = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Snake {
            static instance: Snake = Snake {
                player_id: ::std::option::Option::None,
                points: ::std::vec::Vec::new(),
                state: ::std::option::Option::None,
                head_direction: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Snake {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("GameState.Snake").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Snake {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Snake {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    /// Nested message and enums of message `Snake`
    pub mod snake {
        ///  Статус змеи в игре
        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:snakes.GameState.Snake.SnakeState)
        pub enum SnakeState {
            // @@protoc_insertion_point(enum_value:snakes.GameState.Snake.SnakeState.ALIVE)
            ALIVE = 0,
            // @@protoc_insertion_point(enum_value:snakes.GameState.Snake.SnakeState.ZOMBIE)
            ZOMBIE = 1,
        }

        impl ::protobuf::Enum for SnakeState {
            const NAME: &'static str = "SnakeState";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<SnakeState> {
                match value {
                    0 => ::std::option::Option::Some(SnakeState::ALIVE),
                    1 => ::std::option::Option::Some(SnakeState::ZOMBIE),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [SnakeState] = &[
                SnakeState::ALIVE,
                SnakeState::ZOMBIE,
            ];
        }

        impl ::protobuf::EnumFull for SnakeState {
            fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
                static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
                descriptor.get(|| super::super::file_descriptor().enum_by_package_relative_name("GameState.Snake.SnakeState").unwrap()).clone()
            }

            fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
                let index = *self as usize;
                Self::enum_descriptor().value_by_index(index)
            }
        }

        impl ::std::default::Default for SnakeState {
            fn default() -> Self {
                SnakeState::ALIVE
            }
        }

        impl SnakeState {
            pub(in super::super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
                ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SnakeState>("GameState.Snake.SnakeState")
            }
        }
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:snakes.GameAnnouncement)
pub struct GameAnnouncement {
    // message fields
    // @@protoc_insertion_point(field:snakes.GameAnnouncement.players)
    pub players: ::protobuf::MessageField<GamePlayers>,
    // @@protoc_insertion_point(field:snakes.GameAnnouncement.config)
    pub config: ::protobuf::MessageField<GameConfig>,
    // @@protoc_insertion_point(field:snakes.GameAnnouncement.can_join)
    pub can_join: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:snakes.GameAnnouncement.game_name)
    pub game_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:snakes.GameAnnouncement.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GameAnnouncement {
    fn default() -> &'a GameAnnouncement {
        <GameAnnouncement as ::protobuf::Message>::default_instance()
    }
}

impl GameAnnouncement {
    pub fn new() -> GameAnnouncement {
        ::std::default::Default::default()
    }

    // optional bool can_join = 3;

    pub fn can_join(&self) -> bool {
        self.can_join.unwrap_or(true)
    }

    pub fn clear_can_join(&mut self) {
        self.can_join = ::std::option::Option::None;
    }

    pub fn has_can_join(&self) -> bool {
        self.can_join.is_some()
    }

    // Param is passed by value, moved
    pub fn set_can_join(&mut self, v: bool) {
        self.can_join = ::std::option::Option::Some(v);
    }

    // required string game_name = 4;

    pub fn game_name(&self) -> &str {
        match self.game_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_name(&mut self) {
        self.game_name = ::std::option::Option::None;
    }

    pub fn has_game_name(&self) -> bool {
        self.game_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_name(&mut self, v: ::std::string::String) {
        self.game_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_name(&mut self) -> &mut ::std::string::String {
        if self.game_name.is_none() {
            self.game_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_name(&mut self) -> ::std::string::String {
        self.game_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GamePlayers>(
            "players",
            |m: &GameAnnouncement| { &m.players },
            |m: &mut GameAnnouncement| { &mut m.players },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GameConfig>(
            "config",
            |m: &GameAnnouncement| { &m.config },
            |m: &mut GameAnnouncement| { &mut m.config },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "can_join",
            |m: &GameAnnouncement| { &m.can_join },
            |m: &mut GameAnnouncement| { &mut m.can_join },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_name",
            |m: &GameAnnouncement| { &m.game_name },
            |m: &mut GameAnnouncement| { &mut m.game_name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GameAnnouncement>(
            "GameAnnouncement",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GameAnnouncement {
    const NAME: &'static str = "GameAnnouncement";

    fn is_initialized(&self) -> bool {
        if self.players.is_none() {
            return false;
        }
        if self.config.is_none() {
            return false;
        }
        if self.game_name.is_none() {
            return false;
        }
        for v in &self.players {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.players)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.config)?;
                },
                24 => {
                    self.can_join = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    self.game_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.players.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.can_join {
            my_size += 1 + 1;
        }
        if let Some(v) = self.game_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.players.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.config.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.can_join {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.game_name.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GameAnnouncement {
        GameAnnouncement::new()
    }

    fn clear(&mut self) {
        self.players.clear();
        self.config.clear();
        self.can_join = ::std::option::Option::None;
        self.game_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GameAnnouncement {
        static instance: GameAnnouncement = GameAnnouncement {
            players: ::protobuf::MessageField::none(),
            config: ::protobuf::MessageField::none(),
            can_join: ::std::option::Option::None,
            game_name: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GameAnnouncement {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GameAnnouncement").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GameAnnouncement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GameAnnouncement {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Общий формат любого UDP-сообщения
#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:snakes.GameMessage)
pub struct GameMessage {
    // message fields
    // @@protoc_insertion_point(field:snakes.GameMessage.msg_seq)
    pub msg_seq: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:snakes.GameMessage.sender_id)
    pub sender_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:snakes.GameMessage.receiver_id)
    pub receiver_id: ::std::option::Option<i32>,
    // message oneof groups
    pub Type: ::std::option::Option<game_message::Type>,
    // special fields
    // @@protoc_insertion_point(special_field:snakes.GameMessage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GameMessage {
    fn default() -> &'a GameMessage {
        <GameMessage as ::protobuf::Message>::default_instance()
    }
}

impl GameMessage {
    pub fn new() -> GameMessage {
        ::std::default::Default::default()
    }

    // required int64 msg_seq = 1;

    pub fn msg_seq(&self) -> i64 {
        self.msg_seq.unwrap_or(0)
    }

    pub fn clear_msg_seq(&mut self) {
        self.msg_seq = ::std::option::Option::None;
    }

    pub fn has_msg_seq(&self) -> bool {
        self.msg_seq.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_seq(&mut self, v: i64) {
        self.msg_seq = ::std::option::Option::Some(v);
    }

    // optional int32 sender_id = 10;

    pub fn sender_id(&self) -> i32 {
        self.sender_id.unwrap_or(0)
    }

    pub fn clear_sender_id(&mut self) {
        self.sender_id = ::std::option::Option::None;
    }

    pub fn has_sender_id(&self) -> bool {
        self.sender_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_id(&mut self, v: i32) {
        self.sender_id = ::std::option::Option::Some(v);
    }

    // optional int32 receiver_id = 11;

    pub fn receiver_id(&self) -> i32 {
        self.receiver_id.unwrap_or(0)
    }

    pub fn clear_receiver_id(&mut self) {
        self.receiver_id = ::std::option::Option::None;
    }

    pub fn has_receiver_id(&self) -> bool {
        self.receiver_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receiver_id(&mut self, v: i32) {
        self.receiver_id = ::std::option::Option::Some(v);
    }

    // optional .snakes.GameMessage.PingMsg ping = 2;

    pub fn ping(&self) -> &game_message::PingMsg {
        match self.Type {
            ::std::option::Option::Some(game_message::Type::Ping(ref v)) => v,
            _ => <game_message::PingMsg as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_ping(&mut self) {
        self.Type = ::std::option::Option::None;
    }

    pub fn has_ping(&self) -> bool {
        match self.Type {
            ::std::option::Option::Some(game_message::Type::Ping(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ping(&mut self, v: game_message::PingMsg) {
        self.Type = ::std::option::Option::Some(game_message::Type::Ping(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ping(&mut self) -> &mut game_message::PingMsg {
        if let ::std::option::Option::Some(game_message::Type::Ping(_)) = self.Type {
        } else {
            self.Type = ::std::option::Option::Some(game_message::Type::Ping(game_message::PingMsg::new()));
        }
        match self.Type {
            ::std::option::Option::Some(game_message::Type::Ping(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ping(&mut self) -> game_message::PingMsg {
        if self.has_ping() {
            match self.Type.take() {
                ::std::option::Option::Some(game_message::Type::Ping(v)) => v,
                _ => panic!(),
            }
        } else {
            game_message::PingMsg::new()
        }
    }

    // optional .snakes.GameMessage.SteerMsg steer = 3;

    pub fn steer(&self) -> &game_message::SteerMsg {
        match self.Type {
            ::std::option::Option::Some(game_message::Type::Steer(ref v)) => v,
            _ => <game_message::SteerMsg as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_steer(&mut self) {
        self.Type = ::std::option::Option::None;
    }

    pub fn has_steer(&self) -> bool {
        match self.Type {
            ::std::option::Option::Some(game_message::Type::Steer(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_steer(&mut self, v: game_message::SteerMsg) {
        self.Type = ::std::option::Option::Some(game_message::Type::Steer(v))
    }

    // Mutable pointer to the field.
    pub fn mut_steer(&mut self) -> &mut game_message::SteerMsg {
        if let ::std::option::Option::Some(game_message::Type::Steer(_)) = self.Type {
        } else {
            self.Type = ::std::option::Option::Some(game_message::Type::Steer(game_message::SteerMsg::new()));
        }
        match self.Type {
            ::std::option::Option::Some(game_message::Type::Steer(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_steer(&mut self) -> game_message::SteerMsg {
        if self.has_steer() {
            match self.Type.take() {
                ::std::option::Option::Some(game_message::Type::Steer(v)) => v,
                _ => panic!(),
            }
        } else {
            game_message::SteerMsg::new()
        }
    }

    // optional .snakes.GameMessage.AckMsg ack = 4;

    pub fn ack(&self) -> &game_message::AckMsg {
        match self.Type {
            ::std::option::Option::Some(game_message::Type::Ack(ref v)) => v,
            _ => <game_message::AckMsg as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_ack(&mut self) {
        self.Type = ::std::option::Option::None;
    }

    pub fn has_ack(&self) -> bool {
        match self.Type {
            ::std::option::Option::Some(game_message::Type::Ack(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ack(&mut self, v: game_message::AckMsg) {
        self.Type = ::std::option::Option::Some(game_message::Type::Ack(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ack(&mut self) -> &mut game_message::AckMsg {
        if let ::std::option::Option::Some(game_message::Type::Ack(_)) = self.Type {
        } else {
            self.Type = ::std::option::Option::Some(game_message::Type::Ack(game_message::AckMsg::new()));
        }
        match self.Type {
            ::std::option::Option::Some(game_message::Type::Ack(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ack(&mut self) -> game_message::AckMsg {
        if self.has_ack() {
            match self.Type.take() {
                ::std::option::Option::Some(game_message::Type::Ack(v)) => v,
                _ => panic!(),
            }
        } else {
            game_message::AckMsg::new()
        }
    }

    // optional .snakes.GameMessage.StateMsg state = 5;

    pub fn state(&self) -> &game_message::StateMsg {
        match self.Type {
            ::std::option::Option::Some(game_message::Type::State(ref v)) => v,
            _ => <game_message::StateMsg as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_state(&mut self) {
        self.Type = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        match self.Type {
            ::std::option::Option::Some(game_message::Type::State(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: game_message::StateMsg) {
        self.Type = ::std::option::Option::Some(game_message::Type::State(v))
    }

    // Mutable pointer to the field.
    pub fn mut_state(&mut self) -> &mut game_message::StateMsg {
        if let ::std::option::Option::Some(game_message::Type::State(_)) = self.Type {
        } else {
            self.Type = ::std::option::Option::Some(game_message::Type::State(game_message::StateMsg::new()));
        }
        match self.Type {
            ::std::option::Option::Some(game_message::Type::State(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_state(&mut self) -> game_message::StateMsg {
        if self.has_state() {
            match self.Type.take() {
                ::std::option::Option::Some(game_message::Type::State(v)) => v,
                _ => panic!(),
            }
        } else {
            game_message::StateMsg::new()
        }
    }

    // optional .snakes.GameMessage.AnnouncementMsg announcement = 6;

    pub fn announcement(&self) -> &game_message::AnnouncementMsg {
        match self.Type {
            ::std::option::Option::Some(game_message::Type::Announcement(ref v)) => v,
            _ => <game_message::AnnouncementMsg as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_announcement(&mut self) {
        self.Type = ::std::option::Option::None;
    }

    pub fn has_announcement(&self) -> bool {
        match self.Type {
            ::std::option::Option::Some(game_message::Type::Announcement(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_announcement(&mut self, v: game_message::AnnouncementMsg) {
        self.Type = ::std::option::Option::Some(game_message::Type::Announcement(v))
    }

    // Mutable pointer to the field.
    pub fn mut_announcement(&mut self) -> &mut game_message::AnnouncementMsg {
        if let ::std::option::Option::Some(game_message::Type::Announcement(_)) = self.Type {
        } else {
            self.Type = ::std::option::Option::Some(game_message::Type::Announcement(game_message::AnnouncementMsg::new()));
        }
        match self.Type {
            ::std::option::Option::Some(game_message::Type::Announcement(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_announcement(&mut self) -> game_message::AnnouncementMsg {
        if self.has_announcement() {
            match self.Type.take() {
                ::std::option::Option::Some(game_message::Type::Announcement(v)) => v,
                _ => panic!(),
            }
        } else {
            game_message::AnnouncementMsg::new()
        }
    }

    // optional .snakes.GameMessage.JoinMsg join = 7;

    pub fn join(&self) -> &game_message::JoinMsg {
        match self.Type {
            ::std::option::Option::Some(game_message::Type::Join(ref v)) => v,
            _ => <game_message::JoinMsg as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_join(&mut self) {
        self.Type = ::std::option::Option::None;
    }

    pub fn has_join(&self) -> bool {
        match self.Type {
            ::std::option::Option::Some(game_message::Type::Join(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_join(&mut self, v: game_message::JoinMsg) {
        self.Type = ::std::option::Option::Some(game_message::Type::Join(v))
    }

    // Mutable pointer to the field.
    pub fn mut_join(&mut self) -> &mut game_message::JoinMsg {
        if let ::std::option::Option::Some(game_message::Type::Join(_)) = self.Type {
        } else {
            self.Type = ::std::option::Option::Some(game_message::Type::Join(game_message::JoinMsg::new()));
        }
        match self.Type {
            ::std::option::Option::Some(game_message::Type::Join(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_join(&mut self) -> game_message::JoinMsg {
        if self.has_join() {
            match self.Type.take() {
                ::std::option::Option::Some(game_message::Type::Join(v)) => v,
                _ => panic!(),
            }
        } else {
            game_message::JoinMsg::new()
        }
    }

    // optional .snakes.GameMessage.ErrorMsg error = 8;

    pub fn error(&self) -> &game_message::ErrorMsg {
        match self.Type {
            ::std::option::Option::Some(game_message::Type::Error(ref v)) => v,
            _ => <game_message::ErrorMsg as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_error(&mut self) {
        self.Type = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        match self.Type {
            ::std::option::Option::Some(game_message::Type::Error(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: game_message::ErrorMsg) {
        self.Type = ::std::option::Option::Some(game_message::Type::Error(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error(&mut self) -> &mut game_message::ErrorMsg {
        if let ::std::option::Option::Some(game_message::Type::Error(_)) = self.Type {
        } else {
            self.Type = ::std::option::Option::Some(game_message::Type::Error(game_message::ErrorMsg::new()));
        }
        match self.Type {
            ::std::option::Option::Some(game_message::Type::Error(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error(&mut self) -> game_message::ErrorMsg {
        if self.has_error() {
            match self.Type.take() {
                ::std::option::Option::Some(game_message::Type::Error(v)) => v,
                _ => panic!(),
            }
        } else {
            game_message::ErrorMsg::new()
        }
    }

    // optional .snakes.GameMessage.RoleChangeMsg role_change = 9;

    pub fn role_change(&self) -> &game_message::RoleChangeMsg {
        match self.Type {
            ::std::option::Option::Some(game_message::Type::RoleChange(ref v)) => v,
            _ => <game_message::RoleChangeMsg as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_role_change(&mut self) {
        self.Type = ::std::option::Option::None;
    }

    pub fn has_role_change(&self) -> bool {
        match self.Type {
            ::std::option::Option::Some(game_message::Type::RoleChange(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_role_change(&mut self, v: game_message::RoleChangeMsg) {
        self.Type = ::std::option::Option::Some(game_message::Type::RoleChange(v))
    }

    // Mutable pointer to the field.
    pub fn mut_role_change(&mut self) -> &mut game_message::RoleChangeMsg {
        if let ::std::option::Option::Some(game_message::Type::RoleChange(_)) = self.Type {
        } else {
            self.Type = ::std::option::Option::Some(game_message::Type::RoleChange(game_message::RoleChangeMsg::new()));
        }
        match self.Type {
            ::std::option::Option::Some(game_message::Type::RoleChange(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_role_change(&mut self) -> game_message::RoleChangeMsg {
        if self.has_role_change() {
            match self.Type.take() {
                ::std::option::Option::Some(game_message::Type::RoleChange(v)) => v,
                _ => panic!(),
            }
        } else {
            game_message::RoleChangeMsg::new()
        }
    }

    // optional .snakes.GameMessage.DiscoverMsg discover = 12;

    pub fn discover(&self) -> &game_message::DiscoverMsg {
        match self.Type {
            ::std::option::Option::Some(game_message::Type::Discover(ref v)) => v,
            _ => <game_message::DiscoverMsg as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_discover(&mut self) {
        self.Type = ::std::option::Option::None;
    }

    pub fn has_discover(&self) -> bool {
        match self.Type {
            ::std::option::Option::Some(game_message::Type::Discover(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_discover(&mut self, v: game_message::DiscoverMsg) {
        self.Type = ::std::option::Option::Some(game_message::Type::Discover(v))
    }

    // Mutable pointer to the field.
    pub fn mut_discover(&mut self) -> &mut game_message::DiscoverMsg {
        if let ::std::option::Option::Some(game_message::Type::Discover(_)) = self.Type {
        } else {
            self.Type = ::std::option::Option::Some(game_message::Type::Discover(game_message::DiscoverMsg::new()));
        }
        match self.Type {
            ::std::option::Option::Some(game_message::Type::Discover(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_discover(&mut self) -> game_message::DiscoverMsg {
        if self.has_discover() {
            match self.Type.take() {
                ::std::option::Option::Some(game_message::Type::Discover(v)) => v,
                _ => panic!(),
            }
        } else {
            game_message::DiscoverMsg::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "msg_seq",
            |m: &GameMessage| { &m.msg_seq },
            |m: &mut GameMessage| { &mut m.msg_seq },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sender_id",
            |m: &GameMessage| { &m.sender_id },
            |m: &mut GameMessage| { &mut m.sender_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "receiver_id",
            |m: &GameMessage| { &m.receiver_id },
            |m: &mut GameMessage| { &mut m.receiver_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, game_message::PingMsg>(
            "ping",
            GameMessage::has_ping,
            GameMessage::ping,
            GameMessage::mut_ping,
            GameMessage::set_ping,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, game_message::SteerMsg>(
            "steer",
            GameMessage::has_steer,
            GameMessage::steer,
            GameMessage::mut_steer,
            GameMessage::set_steer,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, game_message::AckMsg>(
            "ack",
            GameMessage::has_ack,
            GameMessage::ack,
            GameMessage::mut_ack,
            GameMessage::set_ack,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, game_message::StateMsg>(
            "state",
            GameMessage::has_state,
            GameMessage::state,
            GameMessage::mut_state,
            GameMessage::set_state,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, game_message::AnnouncementMsg>(
            "announcement",
            GameMessage::has_announcement,
            GameMessage::announcement,
            GameMessage::mut_announcement,
            GameMessage::set_announcement,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, game_message::JoinMsg>(
            "join",
            GameMessage::has_join,
            GameMessage::join,
            GameMessage::mut_join,
            GameMessage::set_join,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, game_message::ErrorMsg>(
            "error",
            GameMessage::has_error,
            GameMessage::error,
            GameMessage::mut_error,
            GameMessage::set_error,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, game_message::RoleChangeMsg>(
            "role_change",
            GameMessage::has_role_change,
            GameMessage::role_change,
            GameMessage::mut_role_change,
            GameMessage::set_role_change,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, game_message::DiscoverMsg>(
            "discover",
            GameMessage::has_discover,
            GameMessage::discover,
            GameMessage::mut_discover,
            GameMessage::set_discover,
        ));
        oneofs.push(game_message::Type::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GameMessage>(
            "GameMessage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GameMessage {
    const NAME: &'static str = "GameMessage";

    fn is_initialized(&self) -> bool {
        if self.msg_seq.is_none() {
            return false;
        }
        if let Some(game_message::Type::Ping(ref v)) = self.Type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(game_message::Type::Steer(ref v)) = self.Type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(game_message::Type::Ack(ref v)) = self.Type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(game_message::Type::State(ref v)) = self.Type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(game_message::Type::Announcement(ref v)) = self.Type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(game_message::Type::Join(ref v)) = self.Type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(game_message::Type::Error(ref v)) = self.Type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(game_message::Type::RoleChange(ref v)) = self.Type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(game_message::Type::Discover(ref v)) = self.Type {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.msg_seq = ::std::option::Option::Some(is.read_int64()?);
                },
                80 => {
                    self.sender_id = ::std::option::Option::Some(is.read_int32()?);
                },
                88 => {
                    self.receiver_id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.Type = ::std::option::Option::Some(game_message::Type::Ping(is.read_message()?));
                },
                26 => {
                    self.Type = ::std::option::Option::Some(game_message::Type::Steer(is.read_message()?));
                },
                34 => {
                    self.Type = ::std::option::Option::Some(game_message::Type::Ack(is.read_message()?));
                },
                42 => {
                    self.Type = ::std::option::Option::Some(game_message::Type::State(is.read_message()?));
                },
                50 => {
                    self.Type = ::std::option::Option::Some(game_message::Type::Announcement(is.read_message()?));
                },
                58 => {
                    self.Type = ::std::option::Option::Some(game_message::Type::Join(is.read_message()?));
                },
                66 => {
                    self.Type = ::std::option::Option::Some(game_message::Type::Error(is.read_message()?));
                },
                74 => {
                    self.Type = ::std::option::Option::Some(game_message::Type::RoleChange(is.read_message()?));
                },
                98 => {
                    self.Type = ::std::option::Option::Some(game_message::Type::Discover(is.read_message()?));
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.msg_seq {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let Some(v) = self.sender_id {
            my_size += ::protobuf::rt::int32_size(10, v);
        }
        if let Some(v) = self.receiver_id {
            my_size += ::protobuf::rt::int32_size(11, v);
        }
        if let ::std::option::Option::Some(ref v) = self.Type {
            match v {
                &game_message::Type::Ping(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &game_message::Type::Steer(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &game_message::Type::Ack(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &game_message::Type::State(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &game_message::Type::Announcement(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &game_message::Type::Join(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &game_message::Type::Error(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &game_message::Type::RoleChange(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &game_message::Type::Discover(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.msg_seq {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.sender_id {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.receiver_id {
            os.write_int32(11, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.Type {
            match v {
                &game_message::Type::Ping(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
                &game_message::Type::Steer(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                },
                &game_message::Type::Ack(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
                },
                &game_message::Type::State(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
                },
                &game_message::Type::Announcement(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
                },
                &game_message::Type::Join(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
                },
                &game_message::Type::Error(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
                },
                &game_message::Type::RoleChange(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
                },
                &game_message::Type::Discover(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GameMessage {
        GameMessage::new()
    }

    fn clear(&mut self) {
        self.msg_seq = ::std::option::Option::None;
        self.sender_id = ::std::option::Option::None;
        self.receiver_id = ::std::option::Option::None;
        self.Type = ::std::option::Option::None;
        self.Type = ::std::option::Option::None;
        self.Type = ::std::option::Option::None;
        self.Type = ::std::option::Option::None;
        self.Type = ::std::option::Option::None;
        self.Type = ::std::option::Option::None;
        self.Type = ::std::option::Option::None;
        self.Type = ::std::option::Option::None;
        self.Type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GameMessage {
        static instance: GameMessage = GameMessage {
            msg_seq: ::std::option::Option::None,
            sender_id: ::std::option::Option::None,
            receiver_id: ::std::option::Option::None,
            Type: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GameMessage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GameMessage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GameMessage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GameMessage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `GameMessage`
pub mod game_message {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:snakes.GameMessage.Type)
    pub enum Type {
        // @@protoc_insertion_point(oneof_field:snakes.GameMessage.ping)
        Ping(PingMsg),
        // @@protoc_insertion_point(oneof_field:snakes.GameMessage.steer)
        Steer(SteerMsg),
        // @@protoc_insertion_point(oneof_field:snakes.GameMessage.ack)
        Ack(AckMsg),
        // @@protoc_insertion_point(oneof_field:snakes.GameMessage.state)
        State(StateMsg),
        // @@protoc_insertion_point(oneof_field:snakes.GameMessage.announcement)
        Announcement(AnnouncementMsg),
        // @@protoc_insertion_point(oneof_field:snakes.GameMessage.join)
        Join(JoinMsg),
        // @@protoc_insertion_point(oneof_field:snakes.GameMessage.error)
        Error(ErrorMsg),
        // @@protoc_insertion_point(oneof_field:snakes.GameMessage.role_change)
        RoleChange(RoleChangeMsg),
        // @@protoc_insertion_point(oneof_field:snakes.GameMessage.discover)
        Discover(DiscoverMsg),
    }

    impl ::protobuf::Oneof for Type {
    }

    impl ::protobuf::OneofFull for Type {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::GameMessage as ::protobuf::MessageFull>::descriptor().oneof_by_name("Type").unwrap()).clone()
        }
    }

    impl Type {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Type>("Type")
        }
    }
    ///  Ничего не меняем, просто говорим, что мы живы
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:snakes.GameMessage.PingMsg)
    pub struct PingMsg {
        // special fields
        // @@protoc_insertion_point(special_field:snakes.GameMessage.PingMsg.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PingMsg {
        fn default() -> &'a PingMsg {
            <PingMsg as ::protobuf::Message>::default_instance()
        }
    }

    impl PingMsg {
        pub fn new() -> PingMsg {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PingMsg>(
                "GameMessage.PingMsg",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PingMsg {
        const NAME: &'static str = "PingMsg";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PingMsg {
            PingMsg::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PingMsg {
            static instance: PingMsg = PingMsg {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PingMsg {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("GameMessage.PingMsg").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PingMsg {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PingMsg {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    ///  Не-центральный игрок просит повернуть голову змеи
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:snakes.GameMessage.SteerMsg)
    pub struct SteerMsg {
        // message fields
        // @@protoc_insertion_point(field:snakes.GameMessage.SteerMsg.direction)
        pub direction: ::std::option::Option<::protobuf::EnumOrUnknown<super::Direction>>,
        // special fields
        // @@protoc_insertion_point(special_field:snakes.GameMessage.SteerMsg.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SteerMsg {
        fn default() -> &'a SteerMsg {
            <SteerMsg as ::protobuf::Message>::default_instance()
        }
    }

    impl SteerMsg {
        pub fn new() -> SteerMsg {
            ::std::default::Default::default()
        }

        // required .snakes.Direction direction = 1;

        pub fn direction(&self) -> super::Direction {
            match self.direction {
                Some(e) => e.enum_value_or(super::Direction::UP),
                None => super::Direction::UP,
            }
        }

        pub fn clear_direction(&mut self) {
            self.direction = ::std::option::Option::None;
        }

        pub fn has_direction(&self) -> bool {
            self.direction.is_some()
        }

        // Param is passed by value, moved
        pub fn set_direction(&mut self, v: super::Direction) {
            self.direction = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "direction",
                |m: &SteerMsg| { &m.direction },
                |m: &mut SteerMsg| { &mut m.direction },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SteerMsg>(
                "GameMessage.SteerMsg",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SteerMsg {
        const NAME: &'static str = "SteerMsg";

        fn is_initialized(&self) -> bool {
            if self.direction.is_none() {
                return false;
            }
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.direction = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.direction {
                my_size += ::protobuf::rt::int32_size(1, v.value());
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.direction {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SteerMsg {
            SteerMsg::new()
        }

        fn clear(&mut self) {
            self.direction = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SteerMsg {
            static instance: SteerMsg = SteerMsg {
                direction: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SteerMsg {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("GameMessage.SteerMsg").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SteerMsg {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SteerMsg {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    ///  Подтверждение сообщения с таким же seq
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:snakes.GameMessage.AckMsg)
    pub struct AckMsg {
        // special fields
        // @@protoc_insertion_point(special_field:snakes.GameMessage.AckMsg.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AckMsg {
        fn default() -> &'a AckMsg {
            <AckMsg as ::protobuf::Message>::default_instance()
        }
    }

    impl AckMsg {
        pub fn new() -> AckMsg {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AckMsg>(
                "GameMessage.AckMsg",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AckMsg {
        const NAME: &'static str = "AckMsg";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AckMsg {
            AckMsg::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AckMsg {
            static instance: AckMsg = AckMsg {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AckMsg {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("GameMessage.AckMsg").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AckMsg {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AckMsg {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    ///  Центральный узел сообщает остальным игрокам состояние игры
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:snakes.GameMessage.StateMsg)
    pub struct StateMsg {
        // message fields
        // @@protoc_insertion_point(field:snakes.GameMessage.StateMsg.state)
        pub state: ::protobuf::MessageField<super::GameState>,
        // special fields
        // @@protoc_insertion_point(special_field:snakes.GameMessage.StateMsg.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a StateMsg {
        fn default() -> &'a StateMsg {
            <StateMsg as ::protobuf::Message>::default_instance()
        }
    }

    impl StateMsg {
        pub fn new() -> StateMsg {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::GameState>(
                "state",
                |m: &StateMsg| { &m.state },
                |m: &mut StateMsg| { &mut m.state },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StateMsg>(
                "GameMessage.StateMsg",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for StateMsg {
        const NAME: &'static str = "StateMsg";

        fn is_initialized(&self) -> bool {
            if self.state.is_none() {
                return false;
            }
            for v in &self.state {
                if !v.is_initialized() {
                    return false;
                }
            };
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.state)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.state.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.state.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> StateMsg {
            StateMsg::new()
        }

        fn clear(&mut self) {
            self.state.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static StateMsg {
            static instance: StateMsg = StateMsg {
                state: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for StateMsg {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("GameMessage.StateMsg").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for StateMsg {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for StateMsg {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    ///  Уведомление об идущих играх, регулярно отправляется multicast-ом или в ответ на DiscoverMsg
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:snakes.GameMessage.AnnouncementMsg)
    pub struct AnnouncementMsg {
        // message fields
        // @@protoc_insertion_point(field:snakes.GameMessage.AnnouncementMsg.games)
        pub games: ::std::vec::Vec<super::GameAnnouncement>,
        // special fields
        // @@protoc_insertion_point(special_field:snakes.GameMessage.AnnouncementMsg.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AnnouncementMsg {
        fn default() -> &'a AnnouncementMsg {
            <AnnouncementMsg as ::protobuf::Message>::default_instance()
        }
    }

    impl AnnouncementMsg {
        pub fn new() -> AnnouncementMsg {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "games",
                |m: &AnnouncementMsg| { &m.games },
                |m: &mut AnnouncementMsg| { &mut m.games },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AnnouncementMsg>(
                "GameMessage.AnnouncementMsg",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AnnouncementMsg {
        const NAME: &'static str = "AnnouncementMsg";

        fn is_initialized(&self) -> bool {
            for v in &self.games {
                if !v.is_initialized() {
                    return false;
                }
            };
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.games.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.games {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.games {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AnnouncementMsg {
            AnnouncementMsg::new()
        }

        fn clear(&mut self) {
            self.games.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AnnouncementMsg {
            static instance: AnnouncementMsg = AnnouncementMsg {
                games: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AnnouncementMsg {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("GameMessage.AnnouncementMsg").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AnnouncementMsg {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AnnouncementMsg {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    ///  Запрос информации об идущих играх
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:snakes.GameMessage.DiscoverMsg)
    pub struct DiscoverMsg {
        // special fields
        // @@protoc_insertion_point(special_field:snakes.GameMessage.DiscoverMsg.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DiscoverMsg {
        fn default() -> &'a DiscoverMsg {
            <DiscoverMsg as ::protobuf::Message>::default_instance()
        }
    }

    impl DiscoverMsg {
        pub fn new() -> DiscoverMsg {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(0);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DiscoverMsg>(
                "GameMessage.DiscoverMsg",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for DiscoverMsg {
        const NAME: &'static str = "DiscoverMsg";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DiscoverMsg {
            DiscoverMsg::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DiscoverMsg {
            static instance: DiscoverMsg = DiscoverMsg {
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for DiscoverMsg {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("GameMessage.DiscoverMsg").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DiscoverMsg {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for DiscoverMsg {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    ///  Новый игрок хочет присоединиться к идущей игре
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:snakes.GameMessage.JoinMsg)
    pub struct JoinMsg {
        // message fields
        // @@protoc_insertion_point(field:snakes.GameMessage.JoinMsg.player_type)
        pub player_type: ::std::option::Option<::protobuf::EnumOrUnknown<super::PlayerType>>,
        // @@protoc_insertion_point(field:snakes.GameMessage.JoinMsg.player_name)
        pub player_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:snakes.GameMessage.JoinMsg.game_name)
        pub game_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:snakes.GameMessage.JoinMsg.requested_role)
        pub requested_role: ::std::option::Option<::protobuf::EnumOrUnknown<super::NodeRole>>,
        // special fields
        // @@protoc_insertion_point(special_field:snakes.GameMessage.JoinMsg.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a JoinMsg {
        fn default() -> &'a JoinMsg {
            <JoinMsg as ::protobuf::Message>::default_instance()
        }
    }

    impl JoinMsg {
        pub fn new() -> JoinMsg {
            ::std::default::Default::default()
        }

        // optional .snakes.PlayerType player_type = 1;

        pub fn player_type(&self) -> super::PlayerType {
            match self.player_type {
                Some(e) => e.enum_value_or(super::PlayerType::HUMAN),
                None => super::PlayerType::HUMAN,
            }
        }

        pub fn clear_player_type(&mut self) {
            self.player_type = ::std::option::Option::None;
        }

        pub fn has_player_type(&self) -> bool {
            self.player_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_type(&mut self, v: super::PlayerType) {
            self.player_type = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // required string player_name = 3;

        pub fn player_name(&self) -> &str {
            match self.player_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_player_name(&mut self) {
            self.player_name = ::std::option::Option::None;
        }

        pub fn has_player_name(&self) -> bool {
            self.player_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_name(&mut self, v: ::std::string::String) {
            self.player_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_player_name(&mut self) -> &mut ::std::string::String {
            if self.player_name.is_none() {
                self.player_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.player_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_player_name(&mut self) -> ::std::string::String {
            self.player_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // required string game_name = 4;

        pub fn game_name(&self) -> &str {
            match self.game_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_game_name(&mut self) {
            self.game_name = ::std::option::Option::None;
        }

        pub fn has_game_name(&self) -> bool {
            self.game_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_name(&mut self, v: ::std::string::String) {
            self.game_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_game_name(&mut self) -> &mut ::std::string::String {
            if self.game_name.is_none() {
                self.game_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.game_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_game_name(&mut self) -> ::std::string::String {
            self.game_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // required .snakes.NodeRole requested_role = 5;

        pub fn requested_role(&self) -> super::NodeRole {
            match self.requested_role {
                Some(e) => e.enum_value_or(super::NodeRole::NORMAL),
                None => super::NodeRole::NORMAL,
            }
        }

        pub fn clear_requested_role(&mut self) {
            self.requested_role = ::std::option::Option::None;
        }

        pub fn has_requested_role(&self) -> bool {
            self.requested_role.is_some()
        }

        // Param is passed by value, moved
        pub fn set_requested_role(&mut self, v: super::NodeRole) {
            self.requested_role = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "player_type",
                |m: &JoinMsg| { &m.player_type },
                |m: &mut JoinMsg| { &mut m.player_type },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "player_name",
                |m: &JoinMsg| { &m.player_name },
                |m: &mut JoinMsg| { &mut m.player_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "game_name",
                |m: &JoinMsg| { &m.game_name },
                |m: &mut JoinMsg| { &mut m.game_name },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "requested_role",
                |m: &JoinMsg| { &m.requested_role },
                |m: &mut JoinMsg| { &mut m.requested_role },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<JoinMsg>(
                "GameMessage.JoinMsg",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for JoinMsg {
        const NAME: &'static str = "JoinMsg";

        fn is_initialized(&self) -> bool {
            if self.player_name.is_none() {
                return false;
            }
            if self.game_name.is_none() {
                return false;
            }
            if self.requested_role.is_none() {
                return false;
            }
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.player_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    26 => {
                        self.player_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    34 => {
                        self.game_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    40 => {
                        self.requested_role = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.player_type {
                my_size += ::protobuf::rt::int32_size(1, v.value());
            }
            if let Some(v) = self.player_name.as_ref() {
                my_size += ::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.game_name.as_ref() {
                my_size += ::protobuf::rt::string_size(4, &v);
            }
            if let Some(v) = self.requested_role {
                my_size += ::protobuf::rt::int32_size(5, v.value());
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.player_type {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.player_name.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.game_name.as_ref() {
                os.write_string(4, v)?;
            }
            if let Some(v) = self.requested_role {
                os.write_enum(5, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> JoinMsg {
            JoinMsg::new()
        }

        fn clear(&mut self) {
            self.player_type = ::std::option::Option::None;
            self.player_name = ::std::option::Option::None;
            self.game_name = ::std::option::Option::None;
            self.requested_role = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static JoinMsg {
            static instance: JoinMsg = JoinMsg {
                player_type: ::std::option::Option::None,
                player_name: ::std::option::Option::None,
                game_name: ::std::option::Option::None,
                requested_role: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for JoinMsg {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("GameMessage.JoinMsg").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for JoinMsg {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for JoinMsg {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    ///  Ошибка операции (например отказ в присоединении к игре, т.к. нет места на поле)
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:snakes.GameMessage.ErrorMsg)
    pub struct ErrorMsg {
        // message fields
        // @@protoc_insertion_point(field:snakes.GameMessage.ErrorMsg.error_message)
        pub error_message: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:snakes.GameMessage.ErrorMsg.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ErrorMsg {
        fn default() -> &'a ErrorMsg {
            <ErrorMsg as ::protobuf::Message>::default_instance()
        }
    }

    impl ErrorMsg {
        pub fn new() -> ErrorMsg {
            ::std::default::Default::default()
        }

        // required string error_message = 1;

        pub fn error_message(&self) -> &str {
            match self.error_message.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_error_message(&mut self) {
            self.error_message = ::std::option::Option::None;
        }

        pub fn has_error_message(&self) -> bool {
            self.error_message.is_some()
        }

        // Param is passed by value, moved
        pub fn set_error_message(&mut self, v: ::std::string::String) {
            self.error_message = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_error_message(&mut self) -> &mut ::std::string::String {
            if self.error_message.is_none() {
                self.error_message = ::std::option::Option::Some(::std::string::String::new());
            }
            self.error_message.as_mut().unwrap()
        }

        // Take field
        pub fn take_error_message(&mut self) -> ::std::string::String {
            self.error_message.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "error_message",
                |m: &ErrorMsg| { &m.error_message },
                |m: &mut ErrorMsg| { &mut m.error_message },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ErrorMsg>(
                "GameMessage.ErrorMsg",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ErrorMsg {
        const NAME: &'static str = "ErrorMsg";

        fn is_initialized(&self) -> bool {
            if self.error_message.is_none() {
                return false;
            }
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.error_message = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.error_message.as_ref() {
                my_size += ::protobuf::rt::string_size(1, &v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.error_message.as_ref() {
                os.write_string(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ErrorMsg {
            ErrorMsg::new()
        }

        fn clear(&mut self) {
            self.error_message = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ErrorMsg {
            static instance: ErrorMsg = ErrorMsg {
                error_message: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ErrorMsg {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("GameMessage.ErrorMsg").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ErrorMsg {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ErrorMsg {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    ///  Сообщение о смене роли:
    ///  1. от заместителя другим игрокам о том, что пора начинать считать его главным (sender_role = MASTER)
    ///  2. от осознанно выходящего игрока (sender_role = VIEWER)
    ///  3. от главного к умершему игроку (receiver_role = VIEWER)
    ///  4. в комбинации с 1,2 или отдельно от них: назначение кого-то заместителем (receiver_role = DEPUTY)
    ///  5. в комбинации с 2 от главного узла заместителю о том, что он становится главным (receiver_role = MASTER)
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:snakes.GameMessage.RoleChangeMsg)
    pub struct RoleChangeMsg {
        // message fields
        // @@protoc_insertion_point(field:snakes.GameMessage.RoleChangeMsg.sender_role)
        pub sender_role: ::std::option::Option<::protobuf::EnumOrUnknown<super::NodeRole>>,
        // @@protoc_insertion_point(field:snakes.GameMessage.RoleChangeMsg.receiver_role)
        pub receiver_role: ::std::option::Option<::protobuf::EnumOrUnknown<super::NodeRole>>,
        // special fields
        // @@protoc_insertion_point(special_field:snakes.GameMessage.RoleChangeMsg.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RoleChangeMsg {
        fn default() -> &'a RoleChangeMsg {
            <RoleChangeMsg as ::protobuf::Message>::default_instance()
        }
    }

    impl RoleChangeMsg {
        pub fn new() -> RoleChangeMsg {
            ::std::default::Default::default()
        }

        // optional .snakes.NodeRole sender_role = 1;

        pub fn sender_role(&self) -> super::NodeRole {
            match self.sender_role {
                Some(e) => e.enum_value_or(super::NodeRole::NORMAL),
                None => super::NodeRole::NORMAL,
            }
        }

        pub fn clear_sender_role(&mut self) {
            self.sender_role = ::std::option::Option::None;
        }

        pub fn has_sender_role(&self) -> bool {
            self.sender_role.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sender_role(&mut self, v: super::NodeRole) {
            self.sender_role = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        // optional .snakes.NodeRole receiver_role = 2;

        pub fn receiver_role(&self) -> super::NodeRole {
            match self.receiver_role {
                Some(e) => e.enum_value_or(super::NodeRole::NORMAL),
                None => super::NodeRole::NORMAL,
            }
        }

        pub fn clear_receiver_role(&mut self) {
            self.receiver_role = ::std::option::Option::None;
        }

        pub fn has_receiver_role(&self) -> bool {
            self.receiver_role.is_some()
        }

        // Param is passed by value, moved
        pub fn set_receiver_role(&mut self, v: super::NodeRole) {
            self.receiver_role = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "sender_role",
                |m: &RoleChangeMsg| { &m.sender_role },
                |m: &mut RoleChangeMsg| { &mut m.sender_role },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "receiver_role",
                |m: &RoleChangeMsg| { &m.receiver_role },
                |m: &mut RoleChangeMsg| { &mut m.receiver_role },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RoleChangeMsg>(
                "GameMessage.RoleChangeMsg",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RoleChangeMsg {
        const NAME: &'static str = "RoleChangeMsg";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.sender_role = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    16 => {
                        self.receiver_role = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.sender_role {
                my_size += ::protobuf::rt::int32_size(1, v.value());
            }
            if let Some(v) = self.receiver_role {
                my_size += ::protobuf::rt::int32_size(2, v.value());
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.sender_role {
                os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.receiver_role {
                os.write_enum(2, ::protobuf::EnumOrUnknown::value(&v))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RoleChangeMsg {
            RoleChangeMsg::new()
        }

        fn clear(&mut self) {
            self.sender_role = ::std::option::Option::None;
            self.receiver_role = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RoleChangeMsg {
            static instance: RoleChangeMsg = RoleChangeMsg {
                sender_role: ::std::option::Option::None,
                receiver_role: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RoleChangeMsg {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("GameMessage.RoleChangeMsg").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RoleChangeMsg {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RoleChangeMsg {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

///  Роль узла в топологии связей узлов в пределах игры
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:snakes.NodeRole)
pub enum NodeRole {
    // @@protoc_insertion_point(enum_value:snakes.NodeRole.NORMAL)
    NORMAL = 0,
    // @@protoc_insertion_point(enum_value:snakes.NodeRole.MASTER)
    MASTER = 1,
    // @@protoc_insertion_point(enum_value:snakes.NodeRole.DEPUTY)
    DEPUTY = 2,
    // @@protoc_insertion_point(enum_value:snakes.NodeRole.VIEWER)
    VIEWER = 3,
}

impl ::protobuf::Enum for NodeRole {
    const NAME: &'static str = "NodeRole";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<NodeRole> {
        match value {
            0 => ::std::option::Option::Some(NodeRole::NORMAL),
            1 => ::std::option::Option::Some(NodeRole::MASTER),
            2 => ::std::option::Option::Some(NodeRole::DEPUTY),
            3 => ::std::option::Option::Some(NodeRole::VIEWER),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [NodeRole] = &[
        NodeRole::NORMAL,
        NodeRole::MASTER,
        NodeRole::DEPUTY,
        NodeRole::VIEWER,
    ];
}

impl ::protobuf::EnumFull for NodeRole {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("NodeRole").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for NodeRole {
    fn default() -> Self {
        NodeRole::NORMAL
    }
}

impl NodeRole {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<NodeRole>("NodeRole")
    }
}

///  Тип игрока
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:snakes.PlayerType)
pub enum PlayerType {
    // @@protoc_insertion_point(enum_value:snakes.PlayerType.HUMAN)
    HUMAN = 0,
    // @@protoc_insertion_point(enum_value:snakes.PlayerType.ROBOT)
    ROBOT = 1,
}

impl ::protobuf::Enum for PlayerType {
    const NAME: &'static str = "PlayerType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PlayerType> {
        match value {
            0 => ::std::option::Option::Some(PlayerType::HUMAN),
            1 => ::std::option::Option::Some(PlayerType::ROBOT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [PlayerType] = &[
        PlayerType::HUMAN,
        PlayerType::ROBOT,
    ];
}

impl ::protobuf::EnumFull for PlayerType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("PlayerType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for PlayerType {
    fn default() -> Self {
        PlayerType::HUMAN
    }
}

impl PlayerType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<PlayerType>("PlayerType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:snakes.Direction)
pub enum Direction {
    // @@protoc_insertion_point(enum_value:snakes.Direction.UP)
    UP = 1,
    // @@protoc_insertion_point(enum_value:snakes.Direction.DOWN)
    DOWN = 2,
    // @@protoc_insertion_point(enum_value:snakes.Direction.LEFT)
    LEFT = 3,
    // @@protoc_insertion_point(enum_value:snakes.Direction.RIGHT)
    RIGHT = 4,
}

impl ::protobuf::Enum for Direction {
    const NAME: &'static str = "Direction";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Direction> {
        match value {
            1 => ::std::option::Option::Some(Direction::UP),
            2 => ::std::option::Option::Some(Direction::DOWN),
            3 => ::std::option::Option::Some(Direction::LEFT),
            4 => ::std::option::Option::Some(Direction::RIGHT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [Direction] = &[
        Direction::UP,
        Direction::DOWN,
        Direction::LEFT,
        Direction::RIGHT,
    ];
}

impl ::protobuf::EnumFull for Direction {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("Direction").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            Direction::UP => 0,
            Direction::DOWN => 1,
            Direction::LEFT => 2,
            Direction::RIGHT => 3,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for Direction {
    fn default() -> Self {
        Direction::UP
    }
}

impl Direction {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Direction>("Direction")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x10src/snakes.proto\x12\x06snakes\"\xce\x01\n\nGamePlayer\x12\x12\n\
    \x04name\x18\x01\x20\x02(\tR\x04name\x12\x0e\n\x02id\x18\x02\x20\x02(\
    \x05R\x02id\x12\x1d\n\nip_address\x18\x03\x20\x01(\tR\tipAddress\x12\x12\
    \n\x04port\x18\x04\x20\x01(\x05R\x04port\x12$\n\x04role\x18\x05\x20\x02(\
    \x0e2\x10.snakes.NodeRoleR\x04role\x12-\n\x04type\x18\x06\x20\x01(\x0e2\
    \x12.snakes.PlayerType:\x05HUMANR\x04type\x12\x14\n\x05score\x18\x07\x20\
    \x02(\x05R\x05score\"\x92\x01\n\nGameConfig\x12\x18\n\x05width\x18\x01\
    \x20\x01(\x05:\x0240R\x05width\x12\x1a\n\x06height\x18\x02\x20\x01(\x05:\
    \x0230R\x06height\x12\"\n\x0bfood_static\x18\x03\x20\x01(\x05:\x011R\nfo\
    odStatic\x12*\n\x0estate_delay_ms\x18\x05\x20\x01(\x05:\x041000R\x0cstat\
    eDelayMs\";\n\x0bGamePlayers\x12,\n\x07players\x18\x01\x20\x03(\x0b2\x12\
    .snakes.GamePlayerR\x07players\"\xde\x03\n\tGameState\x12\x1f\n\x0bstate\
    _order\x18\x01\x20\x02(\x05R\nstateOrder\x12/\n\x06snakes\x18\x02\x20\
    \x03(\x0b2\x17.snakes.GameState.SnakeR\x06snakes\x12-\n\x05foods\x18\x03\
    \x20\x03(\x0b2\x17.snakes.GameState.CoordR\x05foods\x12-\n\x07players\
    \x18\x04\x20\x02(\x0b2\x13.snakes.GamePlayersR\x07players\x1a)\n\x05Coor\
    d\x12\x0f\n\x01x\x18\x01\x20\x01(\x11:\x010R\x01x\x12\x0f\n\x01y\x18\x02\
    \x20\x01(\x11:\x010R\x01y\x1a\xf5\x01\n\x05Snake\x12\x1b\n\tplayer_id\
    \x18\x01\x20\x02(\x05R\x08playerId\x12/\n\x06points\x18\x02\x20\x03(\x0b\
    2\x17.snakes.GameState.CoordR\x06points\x12?\n\x05state\x18\x03\x20\x02(\
    \x0e2\".snakes.GameState.Snake.SnakeState:\x05ALIVER\x05state\x128\n\x0e\
    head_direction\x18\x04\x20\x02(\x0e2\x11.snakes.DirectionR\rheadDirectio\
    n\"#\n\nSnakeState\x12\t\n\x05ALIVE\x10\0\x12\n\n\x06ZOMBIE\x10\x01\"\
    \xab\x01\n\x10GameAnnouncement\x12-\n\x07players\x18\x01\x20\x02(\x0b2\
    \x13.snakes.GamePlayersR\x07players\x12*\n\x06config\x18\x02\x20\x02(\
    \x0b2\x12.snakes.GameConfigR\x06config\x12\x1f\n\x08can_join\x18\x03\x20\
    \x01(\x08:\x04trueR\x07canJoin\x12\x1b\n\tgame_name\x18\x04\x20\x02(\tR\
    \x08gameName\"\xb8\t\n\x0bGameMessage\x12\x17\n\x07msg_seq\x18\x01\x20\
    \x02(\x03R\x06msgSeq\x12\x1b\n\tsender_id\x18\n\x20\x01(\x05R\x08senderI\
    d\x12\x1f\n\x0breceiver_id\x18\x0b\x20\x01(\x05R\nreceiverId\x121\n\x04p\
    ing\x18\x02\x20\x01(\x0b2\x1b.snakes.GameMessage.PingMsgH\0R\x04ping\x12\
    4\n\x05steer\x18\x03\x20\x01(\x0b2\x1c.snakes.GameMessage.SteerMsgH\0R\
    \x05steer\x12.\n\x03ack\x18\x04\x20\x01(\x0b2\x1a.snakes.GameMessage.Ack\
    MsgH\0R\x03ack\x124\n\x05state\x18\x05\x20\x01(\x0b2\x1c.snakes.GameMess\
    age.StateMsgH\0R\x05state\x12I\n\x0cannouncement\x18\x06\x20\x01(\x0b2#.\
    snakes.GameMessage.AnnouncementMsgH\0R\x0cannouncement\x121\n\x04join\
    \x18\x07\x20\x01(\x0b2\x1b.snakes.GameMessage.JoinMsgH\0R\x04join\x124\n\
    \x05error\x18\x08\x20\x01(\x0b2\x1c.snakes.GameMessage.ErrorMsgH\0R\x05e\
    rror\x12D\n\x0brole_change\x18\t\x20\x01(\x0b2!.snakes.GameMessage.RoleC\
    hangeMsgH\0R\nroleChange\x12=\n\x08discover\x18\x0c\x20\x01(\x0b2\x1f.sn\
    akes.GameMessage.DiscoverMsgH\0R\x08discover\x1a\t\n\x07PingMsg\x1a;\n\
    \x08SteerMsg\x12/\n\tdirection\x18\x01\x20\x02(\x0e2\x11.snakes.Directio\
    nR\tdirection\x1a\x08\n\x06AckMsg\x1a3\n\x08StateMsg\x12'\n\x05state\x18\
    \x01\x20\x02(\x0b2\x11.snakes.GameStateR\x05state\x1aA\n\x0fAnnouncement\
    Msg\x12.\n\x05games\x18\x01\x20\x03(\x0b2\x18.snakes.GameAnnouncementR\
    \x05games\x1a\r\n\x0bDiscoverMsg\x1a\xbc\x01\n\x07JoinMsg\x12:\n\x0bplay\
    er_type\x18\x01\x20\x01(\x0e2\x12.snakes.PlayerType:\x05HUMANR\nplayerTy\
    pe\x12\x1f\n\x0bplayer_name\x18\x03\x20\x02(\tR\nplayerName\x12\x1b\n\tg\
    ame_name\x18\x04\x20\x02(\tR\x08gameName\x127\n\x0erequested_role\x18\
    \x05\x20\x02(\x0e2\x10.snakes.NodeRoleR\rrequestedRole\x1a/\n\x08ErrorMs\
    g\x12#\n\rerror_message\x18\x01\x20\x02(\tR\x0cerrorMessage\x1ay\n\rRole\
    ChangeMsg\x121\n\x0bsender_role\x18\x01\x20\x01(\x0e2\x10.snakes.NodeRol\
    eR\nsenderRole\x125\n\rreceiver_role\x18\x02\x20\x01(\x0e2\x10.snakes.No\
    deRoleR\x0creceiverRoleB\x06\n\x04Type*:\n\x08NodeRole\x12\n\n\x06NORMAL\
    \x10\0\x12\n\n\x06MASTER\x10\x01\x12\n\n\x06DEPUTY\x10\x02\x12\n\n\x06VI\
    EWER\x10\x03*\"\n\nPlayerType\x12\t\n\x05HUMAN\x10\0\x12\t\n\x05ROBOT\
    \x10\x01*2\n\tDirection\x12\x06\n\x02UP\x10\x01\x12\x08\n\x04DOWN\x10\
    \x02\x12\x08\n\x04LEFT\x10\x03\x12\t\n\x05RIGHT\x10\x04B&\n\x17me.ippoli\
    tov.fit.snakesB\x0bSnakesProtoJ\x85^\n\x07\x12\x05\0\0\x93\x01\x01\n\x08\
    \n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x01\0\x0f\n\x08\n\x01\
    \x08\x12\x03\x02\00\n\t\n\x02\x08\x01\x12\x03\x02\00\n\x08\n\x01\x08\x12\
    \x03\x03\0,\n\t\n\x02\x08\x08\x12\x03\x03\0,\nj\n\x02\x05\0\x12\x04\x06\
    \0\x0b\x01\x1a^\x20\xd0\xa0\xd0\xbe\xd0\xbb\xd1\x8c\x20\xd1\x83\xd0\xb7\
    \xd0\xbb\xd0\xb0\x20\xd0\xb2\x20\xd1\x82\xd0\xbe\xd0\xbf\xd0\xbe\xd0\xbb\
    \xd0\xbe\xd0\xb3\xd0\xb8\xd0\xb8\x20\xd1\x81\xd0\xb2\xd1\x8f\xd0\xb7\xd0\
    \xb5\xd0\xb9\x20\xd1\x83\xd0\xb7\xd0\xbb\xd0\xbe\xd0\xb2\x20\xd0\xb2\x20\
    \xd0\xbf\xd1\x80\xd0\xb5\xd0\xb4\xd0\xb5\xd0\xbb\xd0\xb0\xd1\x85\x20\xd0\
    \xb8\xd0\xb3\xd1\x80\xd1\x8b\n\n\n\n\x03\x05\0\x01\x12\x03\x06\x05\r\nU\
    \n\x04\x05\0\x02\0\x12\x03\x07\x04\x0f\"H\x20\xd0\x9e\xd0\xb1\xd1\x8b\
    \xd1\x87\xd0\xbd\xd1\x8b\xd0\xb9\x20\xd1\x83\xd0\xb7\xd0\xb5\xd0\xbb,\
    \x20\xd0\xbb\xd0\xb8\xd1\x81\xd1\x82\x20\xd0\xb2\x20\xd1\x82\xd0\xbe\xd0\
    \xbf\xd0\xbe\xd0\xbb\xd0\xbe\xd0\xb3\xd0\xb8\xd0\xb8\x20\"\xd0\xb7\xd0\
    \xb2\xd0\xb5\xd0\xb7\xd0\xb4\xd0\xb0\"\n\n\x0c\n\x05\x05\0\x02\0\x01\x12\
    \x03\x07\x04\n\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03\x07\r\x0e\nW\n\x04\
    \x05\0\x02\x01\x12\x03\x08\x04\x0f\"J\x20\xd0\x93\xd0\xbb\xd0\xb0\xd0\
    \xb2\xd0\xbd\xd1\x8b\xd0\xb9\x20\xd1\x83\xd0\xb7\xd0\xb5\xd0\xbb,\x20\
    \xd1\x86\xd0\xb5\xd0\xbd\xd1\x82\xd1\x80\x20\xd0\xb2\x20\xd1\x82\xd0\xbe\
    \xd0\xbf\xd0\xbe\xd0\xbb\xd0\xbe\xd0\xb3\xd0\xb8\xd0\xb8\x20\"\xd0\xb7\
    \xd0\xb2\xd0\xb5\xd0\xb7\xd0\xb4\xd0\xb0\"\n\n\x0c\n\x05\x05\0\x02\x01\
    \x01\x12\x03\x08\x04\n\n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03\x08\r\x0e\n\
    ?\n\x04\x05\0\x02\x02\x12\x03\t\x04\x0f\"2\x20\xd0\x97\xd0\xb0\xd0\xbc\
    \xd0\xb5\xd1\x81\xd1\x82\xd0\xb8\xd1\x82\xd0\xb5\xd0\xbb\xd1\x8c\x20\xd0\
    \xb3\xd0\xbb\xd0\xb0\xd0\xb2\xd0\xbd\xd0\xbe\xd0\xb3\xd0\xbe\x20\xd1\x83\
    \xd0\xb7\xd0\xbb\xd0\xb0\n\n\x0c\n\x05\x05\0\x02\x02\x01\x12\x03\t\x04\n\
    \n\x0c\n\x05\x05\0\x02\x02\x02\x12\x03\t\r\x0e\n\xb8\x01\n\x04\x05\0\x02\
    \x03\x12\x03\n\x04\x0f\"\xaa\x01\x20\xd0\x9d\xd0\xb0\xd0\xb1\xd0\xbb\xd1\
    \x8e\xd0\xb4\xd0\xb0\xd1\x82\xd0\xb5\xd0\xbb\xd1\x8c,\x20\xd0\xbf\xd0\
    \xbe\xd1\x85\xd0\xbe\xd0\xb6\x20\xd0\xbd\xd0\xb0\x20NORMAL,\x20\xd0\xbd\
    \xd0\xbe\x20\xd0\xbd\xd0\xb5\x20\xd0\xb8\xd0\xbc\xd0\xb5\xd0\xb5\xd1\x82\
    \x20\xd0\xb7\xd0\xbc\xd0\xb5\xd0\xb8\x20\xd0\xb2\x20\xd1\x81\xd1\x82\xd0\
    \xb0\xd1\x82\xd1\x83\xd1\x81\xd0\xb5\x20ALIVE,\x20\xd1\x82\xd0\xbe\xd0\
    \xbb\xd1\x8c\xd0\xba\xd0\xbe\x20\xd0\xbf\xd0\xbe\xd0\xbb\xd1\x83\xd1\x87\
    \xd0\xb0\xd0\xb5\xd1\x82\x20\xd0\xbe\xd0\xb1\xd0\xbd\xd0\xbe\xd0\xb2\xd0\
    \xbb\xd0\xb5\xd0\xbd\xd0\xb8\xd1\x8f\x20\xd1\x81\xd1\x82\xd0\xb0\xd1\x82\
    \xd1\x83\xd1\x81\xd0\xb0\n\n\x0c\n\x05\x05\0\x02\x03\x01\x12\x03\n\x04\n\
    \n\x0c\n\x05\x05\0\x02\x03\x02\x12\x03\n\r\x0e\n!\n\x02\x05\x01\x12\x04\
    \x0e\0\x11\x01\x1a\x15\x20\xd0\xa2\xd0\xb8\xd0\xbf\x20\xd0\xb8\xd0\xb3\
    \xd1\x80\xd0\xbe\xd0\xba\xd0\xb0\n\n\n\n\x03\x05\x01\x01\x12\x03\x0e\x05\
    \x0f\n2\n\x04\x05\x01\x02\0\x12\x03\x0f\x04\x0e\"%\x20\xd0\x96\xd0\xb8\
    \xd0\xb2\xd0\xbe\xd0\xb9\x20\xd0\xbf\xd0\xbe\xd0\xbb\xd1\x8c\xd0\xb7\xd0\
    \xbe\xd0\xb2\xd0\xb0\xd1\x82\xd0\xb5\xd0\xbb\xd1\x8c\n\n\x0c\n\x05\x05\
    \x01\x02\0\x01\x12\x03\x0f\x04\t\n\x0c\n\x05\x05\x01\x02\0\x02\x12\x03\
    \x0f\x0c\r\n\x98\x01\n\x04\x05\x01\x02\x01\x12\x03\x10\x04\x0e\"\x8a\x01\
    \x20\xd0\xa0\xd0\xbe\xd0\xb1\xd0\xbe\xd1\x82,\x20\xd1\x83\xd0\xbf\xd1\
    \x80\xd0\xb0\xd0\xb2\xd0\xbb\xd1\x8f\xd0\xb5\xd1\x82\x20\xd1\x81\xd0\xb2\
    \xd0\xbe\xd0\xb5\xd0\xb9\x20\xd0\xb7\xd0\xbc\xd0\xb5\xd1\x91\xd0\xb9\x20\
    \xd1\x81\x20\xd0\xbf\xd0\xbe\xd0\xbc\xd0\xbe\xd1\x89\xd1\x8c\xd1\x8e\x20\
    \xd0\xb0\xd0\xbb\xd0\xb3\xd0\xbe\xd1\x80\xd0\xb8\xd1\x82\xd0\xbc\xd0\xb0\
    \x20(\xd1\x80\xd0\xb5\xd0\xb0\xd0\xbb\xd0\xb8\xd0\xb7\xd0\xbe\xd0\xb2\
    \xd0\xb0\xd0\xbd\xd0\xbe\x20\xd0\xbd\xd0\xb0\x20\"\xd1\x81\xd0\xb5\xd1\
    \x80\xd0\xb2\xd0\xb5\xd1\x80\xd0\xb5\")\n\n\x0c\n\x05\x05\x01\x02\x01\
    \x01\x12\x03\x10\x04\t\n\x0c\n\x05\x05\x01\x02\x01\x02\x12\x03\x10\x0c\r\
    \n\x18\n\x02\x04\0\x12\x04\x14\0\x1c\x01\x1a\x0c\x20\xd0\x98\xd0\xb3\xd1\
    \x80\xd0\xbe\xd0\xba\n\n\n\n\x03\x04\0\x01\x12\x03\x14\x08\x12\nZ\n\x04\
    \x04\0\x02\0\x12\x03\x15\x04\x1d\"M\x20\xd0\x98\xd0\xbc\xd1\x8f\x20\xd0\
    \xb8\xd0\xb3\xd1\x80\xd0\xbe\xd0\xba\xd0\xb0\x20(\xd0\xb4\xd0\xbb\xd1\
    \x8f\x20\xd0\xbe\xd1\x82\xd0\xbe\xd0\xb1\xd1\x80\xd0\xb0\xd0\xb6\xd0\xb5\
    \xd0\xbd\xd0\xb8\xd1\x8f\x20\xd0\xb2\x20\xd0\xb8\xd0\xbd\xd1\x82\xd0\xb5\
    \xd1\x80\xd1\x84\xd0\xb5\xd0\xb9\xd1\x81\xd0\xb5)\n\n\x0c\n\x05\x04\0\
    \x02\0\x04\x12\x03\x15\x04\x0c\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\x15\r\
    \x13\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x15\x14\x18\n\x0c\n\x05\x04\0\
    \x02\0\x03\x12\x03\x15\x1b\x1c\nh\n\x04\x04\0\x02\x01\x12\x03\x16\x04\
    \x1a\"[\x20\xd0\xa3\xd0\xbd\xd0\xb8\xd0\xba\xd0\xb0\xd0\xbb\xd1\x8c\xd0\
    \xbd\xd1\x8b\xd0\xb9\x20\xd0\xb8\xd0\xb4\xd0\xb5\xd0\xbd\xd1\x82\xd0\xb8\
    \xd1\x84\xd0\xb8\xd0\xba\xd0\xb0\xd1\x82\xd0\xbe\xd1\x80\x20\xd0\xb8\xd0\
    \xb3\xd1\x80\xd0\xbe\xd0\xba\xd0\xb0\x20\xd0\xb2\x20\xd0\xbf\xd1\x80\xd0\
    \xb5\xd0\xb4\xd0\xb5\xd0\xbb\xd0\xb0\xd1\x85\x20\xd0\xb8\xd0\xb3\xd1\x80\
    \xd1\x8b\n\n\x0c\n\x05\x04\0\x02\x01\x04\x12\x03\x16\x04\x0c\n\x0c\n\x05\
    \x04\0\x02\x01\x05\x12\x03\x16\r\x12\n\x0c\n\x05\x04\0\x02\x01\x01\x12\
    \x03\x16\x13\x15\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03\x16\x18\x19\n\xb4\
    \x01\n\x04\x04\0\x02\x02\x12\x03\x17\x04#\"\xa6\x01\x20IPv4\x20\xd0\xb8\
    \xd0\xbb\xd0\xb8\x20IPv6\x20\xd0\xb0\xd0\xb4\xd1\x80\xd0\xb5\xd1\x81\x20\
    \xd0\xb8\xd0\xb3\xd1\x80\xd0\xbe\xd0\xba\xd0\xb0\x20\xd0\xb2\x20\xd0\xb2\
    \xd0\xb8\xd0\xb4\xd0\xb5\x20\xd1\x81\xd1\x82\xd1\x80\xd0\xbe\xd0\xba\xd0\
    \xb8.\x20\xd0\x9e\xd1\x82\xd1\x81\xd1\x83\xd1\x82\xd1\x81\xd1\x82\xd0\
    \xb2\xd1\x83\xd0\xb5\xd1\x82\x20\xd0\xb2\x20\xd0\xbe\xd0\xbf\xd0\xb8\xd1\
    \x81\xd0\xb0\xd0\xbd\xd0\xb8\xd0\xb8\x20\xd0\xb8\xd0\xb3\xd1\x80\xd0\xbe\
    \xd0\xba\xd0\xb0-\xd0\xbe\xd1\x82\xd0\xbf\xd1\x80\xd0\xb0\xd0\xb2\xd0\
    \xb8\xd1\x82\xd0\xb5\xd0\xbb\xd1\x8f\x20\xd1\x81\xd0\xbe\xd0\xbe\xd0\xb1\
    \xd1\x89\xd0\xb5\xd0\xbd\xd0\xb8\xd1\x8f\n\n\x0c\n\x05\x04\0\x02\x02\x04\
    \x12\x03\x17\x04\x0c\n\x0c\n\x05\x04\0\x02\x02\x05\x12\x03\x17\r\x13\n\
    \x0c\n\x05\x04\0\x02\x02\x01\x12\x03\x17\x14\x1e\n\x0c\n\x05\x04\0\x02\
    \x02\x03\x12\x03\x17!\"\n\x99\x01\n\x04\x04\0\x02\x03\x12\x03\x18\x04\
    \x1c\"\x8b\x01\x20\xd0\x9f\xd0\xbe\xd1\x80\xd1\x82\x20UDP-\xd1\x81\xd0\
    \xbe\xd0\xba\xd0\xb5\xd1\x82\xd0\xb0\x20\xd0\xb8\xd0\xb3\xd1\x80\xd0\xbe\
    \xd0\xba\xd0\xb0.\x20\xd0\x9e\xd1\x82\xd1\x81\xd1\x83\xd1\x82\xd1\x81\
    \xd1\x82\xd0\xb2\xd1\x83\xd0\xb5\xd1\x82\x20\xd0\xb2\x20\xd0\xbe\xd0\xbf\
    \xd0\xb8\xd1\x81\xd0\xb0\xd0\xbd\xd0\xb8\xd0\xb8\x20\xd0\xb8\xd0\xb3\xd1\
    \x80\xd0\xbe\xd0\xba\xd0\xb0-\xd0\xbe\xd1\x82\xd0\xbf\xd1\x80\xd0\xb0\
    \xd0\xb2\xd0\xb8\xd1\x82\xd0\xb5\xd0\xbb\xd1\x8f\x20\xd1\x81\xd0\xbe\xd0\
    \xbe\xd0\xb1\xd1\x89\xd0\xb5\xd0\xbd\xd0\xb8\xd1\x8f\n\n\x0c\n\x05\x04\0\
    \x02\x03\x04\x12\x03\x18\x04\x0c\n\x0c\n\x05\x04\0\x02\x03\x05\x12\x03\
    \x18\r\x12\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x03\x18\x13\x17\n\x0c\n\x05\
    \x04\0\x02\x03\x03\x12\x03\x18\x1a\x1b\n6\n\x04\x04\0\x02\x04\x12\x03\
    \x19\x04\x1f\")\x20\xd0\xa0\xd0\xbe\xd0\xbb\xd1\x8c\x20\xd1\x83\xd0\xb7\
    \xd0\xbb\xd0\xb0\x20\xd0\xb2\x20\xd1\x82\xd0\xbe\xd0\xbf\xd0\xbe\xd0\xbb\
    \xd0\xbe\xd0\xb3\xd0\xb8\xd0\xb8\n\n\x0c\n\x05\x04\0\x02\x04\x04\x12\x03\
    \x19\x04\x0c\n\x0c\n\x05\x04\0\x02\x04\x06\x12\x03\x19\r\x15\n\x0c\n\x05\
    \x04\0\x02\x04\x01\x12\x03\x19\x16\x1a\n\x0c\n\x05\x04\0\x02\x04\x03\x12\
    \x03\x19\x1d\x1e\n\"\n\x04\x04\0\x02\x05\x12\x03\x1a\x043\"\x15\x20\xd0\
    \xa2\xd0\xb8\xd0\xbf\x20\xd0\xb8\xd0\xb3\xd1\x80\xd0\xbe\xd0\xba\xd0\xb0\
    \n\n\x0c\n\x05\x04\0\x02\x05\x04\x12\x03\x1a\x04\x0c\n\x0c\n\x05\x04\0\
    \x02\x05\x06\x12\x03\x1a\r\x17\n\x0c\n\x05\x04\0\x02\x05\x01\x12\x03\x1a\
    \x18\x1c\n\x0c\n\x05\x04\0\x02\x05\x03\x12\x03\x1a\x1f\x20\n\x0c\n\x05\
    \x04\0\x02\x05\x08\x12\x03\x1a!2\n\x0c\n\x05\x04\0\x02\x05\x07\x12\x03\
    \x1a,1\nL\n\x04\x04\0\x02\x06\x12\x03\x1b\x04\x1d\"?\x20\xd0\xa7\xd0\xb8\
    \xd1\x81\xd0\xbb\xd0\xbe\x20\xd0\xbe\xd1\x87\xd0\xba\xd0\xbe\xd0\xb2,\
    \x20\xd0\xba\xd0\xbe\xd1\x82\xd0\xbe\xd1\x80\xd1\x8b\xd0\xb5\x20\xd0\xbd\
    \xd0\xb0\xd0\xb1\xd1\x80\xd0\xb0\xd0\xbb\x20\xd0\xb8\xd0\xb3\xd1\x80\xd0\
    \xbe\xd0\xba\n\n\x0c\n\x05\x04\0\x02\x06\x04\x12\x03\x1b\x04\x0c\n\x0c\n\
    \x05\x04\0\x02\x06\x05\x12\x03\x1b\r\x12\n\x0c\n\x05\x04\0\x02\x06\x01\
    \x12\x03\x1b\x13\x18\n\x0c\n\x05\x04\0\x02\x06\x03\x12\x03\x1b\x1b\x1c\n\
    x\n\x02\x04\x01\x12\x04\x1f\0$\x01\x1al\x20\xd0\x9f\xd0\xb0\xd1\x80\xd0\
    \xb0\xd0\xbc\xd0\xb5\xd1\x82\xd1\x80\xd1\x8b\x20\xd0\xb8\xd0\xb4\xd1\x83\
    \xd1\x89\xd0\xb5\xd0\xb9\x20\xd0\xb8\xd0\xb3\xd1\x80\xd1\x8b\x20(\xd0\
    \xbd\xd0\xb5\x20\xd0\xb4\xd0\xbe\xd0\xbb\xd0\xb6\xd0\xbd\xd1\x8b\x20\xd0\
    \xbc\xd0\xb5\xd0\xbd\xd1\x8f\xd1\x82\xd1\x8c\xd1\x81\xd1\x8f\x20\xd0\xb2\
    \x20\xd0\xbf\xd1\x80\xd0\xbe\xd1\x86\xd0\xb5\xd1\x81\xd1\x81\xd0\xb5\x20\
    \xd0\xb8\xd0\xb3\xd1\x80\xd1\x8b)\x20\n\n\n\x03\x04\x01\x01\x12\x03\x1f\
    \x08\x12\nI\n\x04\x04\x01\x02\0\x12\x03\x20\x04,\"<\x20\xd0\xa8\xd0\xb8\
    \xd1\x80\xd0\xb8\xd0\xbd\xd0\xb0\x20\xd0\xbf\xd0\xbe\xd0\xbb\xd1\x8f\x20\
    \xd0\xb2\x20\xd0\xba\xd0\xbb\xd0\xb5\xd1\x82\xd0\xba\xd0\xb0\xd1\x85\x20\
    (\xd0\xbe\xd1\x82\x2010\x20\xd0\xb4\xd0\xbe\x20100)\n\n\x0c\n\x05\x04\
    \x01\x02\0\x04\x12\x03\x20\x04\x0c\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03\
    \x20\r\x12\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03\x20\x13\x18\n\x0c\n\x05\
    \x04\x01\x02\0\x03\x12\x03\x20\x1b\x1c\n\x0c\n\x05\x04\x01\x02\0\x08\x12\
    \x03\x20\x1d+\n\x0c\n\x05\x04\x01\x02\0\x07\x12\x03\x20(*\nI\n\x04\x04\
    \x01\x02\x01\x12\x03!\x04-\"<\x20\xd0\x92\xd1\x8b\xd1\x81\xd0\xbe\xd1\
    \x82\xd0\xb0\x20\xd0\xbf\xd0\xbe\xd0\xbb\xd1\x8f\x20\xd0\xb2\x20\xd0\xba\
    \xd0\xbb\xd0\xb5\xd1\x82\xd0\xba\xd0\xb0\xd1\x85\x20(\xd0\xbe\xd1\x82\
    \x2010\x20\xd0\xb4\xd0\xbe\x20100)\n\n\x0c\n\x05\x04\x01\x02\x01\x04\x12\
    \x03!\x04\x0c\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03!\r\x12\n\x0c\n\x05\
    \x04\x01\x02\x01\x01\x12\x03!\x13\x19\n\x0c\n\x05\x04\x01\x02\x01\x03\
    \x12\x03!\x1c\x1d\n\x0c\n\x05\x04\x01\x02\x01\x08\x12\x03!\x1e,\n\x0c\n\
    \x05\x04\x01\x02\x01\x07\x12\x03!)+\n\x83\x01\n\x04\x04\x01\x02\x02\x12\
    \x03\"\x041\"v\x20\xd0\x9a\xd0\xbe\xd0\xbb\xd0\xb8\xd1\x87\xd0\xb5\xd1\
    \x81\xd1\x82\xd0\xb2\xd0\xbe\x20\xd0\xba\xd0\xbb\xd0\xb5\xd1\x82\xd0\xbe\
    \xd0\xba\x20\xd1\x81\x20\xd0\xb5\xd0\xb4\xd0\xbe\xd0\xb9,\x20\xd0\xbd\
    \xd0\xb5\xd0\xb7\xd0\xb0\xd0\xb2\xd0\xb8\xd1\x81\xd0\xb8\xd0\xbc\xd0\xbe\
    \x20\xd0\xbe\xd1\x82\x20\xd1\x87\xd0\xb8\xd1\x81\xd0\xbb\xd0\xb0\x20\xd0\
    \xb8\xd0\xb3\xd1\x80\xd0\xbe\xd0\xba\xd0\xbe\xd0\xb2\x20(\xd0\xbe\xd1\
    \x82\x200\x20\xd0\xb4\xd0\xbe\x20100)\n\n\x0c\n\x05\x04\x01\x02\x02\x04\
    \x12\x03\"\x04\x0c\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\x03\"\r\x12\n\x0c\
    \n\x05\x04\x01\x02\x02\x01\x12\x03\"\x13\x1e\n\x0c\n\x05\x04\x01\x02\x02\
    \x03\x12\x03\"!\"\n\x0c\n\x05\x04\x01\x02\x02\x08\x12\x03\"#0\n\x0c\n\
    \x05\x04\x01\x02\x02\x07\x12\x03\"./\n\x9a\x01\n\x04\x04\x01\x02\x03\x12\
    \x03#\x047\"\x8c\x01\x20\xd0\x97\xd0\xb0\xd0\xb4\xd0\xb5\xd1\x80\xd0\xb6\
    \xd0\xba\xd0\xb0\x20\xd0\xbc\xd0\xb5\xd0\xb6\xd0\xb4\xd1\x83\x20\xd1\x85\
    \xd0\xbe\xd0\xb4\xd0\xb0\xd0\xbc\xd0\xb8\x20(\xd1\x81\xd0\xbc\xd0\xb5\
    \xd0\xbd\xd0\xbe\xd0\xb9\x20\xd1\x81\xd0\xbe\xd1\x81\xd1\x82\xd0\xbe\xd1\
    \x8f\xd0\xbd\xd0\xb8\xd0\xb9)\x20\xd0\xb2\x20\xd0\xb8\xd0\xb3\xd1\x80\
    \xd0\xb5,\x20\xd0\xb2\x20\xd0\xbc\xd0\xb8\xd0\xbb\xd0\xbb\xd0\xb8\xd1\
    \x81\xd0\xb5\xd0\xba\xd1\x83\xd0\xbd\xd0\xb4\xd0\xb0\xd1\x85\x20(\xd0\
    \xbe\xd1\x82\x20100\x20\xd0\xb4\xd0\xbe\x203000)\n\n\x0c\n\x05\x04\x01\
    \x02\x03\x04\x12\x03#\x04\x0c\n\x0c\n\x05\x04\x01\x02\x03\x05\x12\x03#\r\
    \x12\n\x0c\n\x05\x04\x01\x02\x03\x01\x12\x03#\x13!\n\x0c\n\x05\x04\x01\
    \x02\x03\x03\x12\x03#$%\n\x0c\n\x05\x04\x01\x02\x03\x08\x12\x03#&6\n\x0c\
    \n\x05\x04\x01\x02\x03\x07\x12\x03#15\n8\n\x02\x04\x02\x12\x04'\0)\x01\
    \x1a,\x20\xd0\x98\xd0\xb3\xd1\x80\xd0\xbe\xd0\xba\xd0\xb8\x20\xd0\xba\
    \xd0\xbe\xd0\xbd\xd0\xba\xd1\x80\xd0\xb5\xd1\x82\xd0\xbd\xd0\xbe\xd0\xb9\
    \x20\xd0\xb8\xd0\xb3\xd1\x80\xd1\x8b\x20\n\n\n\x03\x04\x02\x01\x12\x03'\
    \x08\x13\n3\n\x04\x04\x02\x02\0\x12\x03(\x04$\"&\x20\xd0\xa1\xd0\xbf\xd0\
    \xb8\xd1\x81\xd0\xbe\xd0\xba\x20\xd0\xb2\xd1\x81\xd0\xb5\xd1\x85\x20\xd0\
    \xb8\xd0\xb3\xd1\x80\xd0\xbe\xd0\xba\xd0\xbe\xd0\xb2\n\n\x0c\n\x05\x04\
    \x02\x02\0\x04\x12\x03(\x04\x0c\n\x0c\n\x05\x04\x02\x02\0\x06\x12\x03(\r\
    \x17\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03(\x18\x1f\n\x0c\n\x05\x04\x02\
    \x02\0\x03\x12\x03(\"#\n\n\n\x02\x05\x02\x12\x04+\00\x01\n\n\n\x03\x05\
    \x02\x01\x12\x03+\x05\x0e\nY\n\x04\x05\x02\x02\0\x12\x03,\x04\x0b\"L\x20\
    \xd0\x92\xd0\xb2\xd0\xb5\xd1\x80\xd1\x85\x20(\xd0\xb2\x20\xd0\xbe\xd1\
    \x82\xd1\x80\xd0\xb8\xd1\x86\xd0\xb0\xd1\x82\xd0\xb5\xd0\xbb\xd1\x8c\xd0\
    \xbd\xd0\xbe\xd0\xbc\x20\xd0\xbd\xd0\xb0\xd0\xbf\xd1\x80\xd0\xb0\xd0\xb2\
    \xd0\xbb\xd0\xb5\xd0\xbd\xd0\xb8\xd0\xb8\x20\xd0\xbe\xd1\x81\xd0\xb8\x20\
    y)\n\n\x0c\n\x05\x05\x02\x02\0\x01\x12\x03,\x04\x06\n\x0c\n\x05\x05\x02\
    \x02\0\x02\x12\x03,\t\n\nW\n\x04\x05\x02\x02\x01\x12\x03-\x04\r\"J\x20\
    \xd0\x92\xd0\xbd\xd0\xb8\xd0\xb7\x20(\xd0\xb2\x20\xd0\xbf\xd0\xbe\xd0\
    \xbb\xd0\xbe\xd0\xb6\xd0\xb8\xd1\x82\xd0\xb5\xd0\xbb\xd1\x8c\xd0\xbd\xd0\
    \xbe\xd0\xbc\x20\xd0\xbd\xd0\xb0\xd0\xbf\xd1\x80\xd0\xb0\xd0\xb2\xd0\xbb\
    \xd0\xb5\xd0\xbd\xd0\xb8\xd0\xb8\x20\xd0\xbe\xd1\x81\xd0\xb8\x20y)\n\n\
    \x0c\n\x05\x05\x02\x02\x01\x01\x12\x03-\x04\x08\n\x0c\n\x05\x05\x02\x02\
    \x01\x02\x12\x03-\x0b\x0c\nY\n\x04\x05\x02\x02\x02\x12\x03.\x04\r\"L\x20\
    \xd0\x92\xd0\xbb\xd0\xb5\xd0\xb2\xd0\xbe\x20(\xd0\xb2\x20\xd0\xbe\xd1\
    \x82\xd1\x80\xd0\xb8\xd1\x86\xd0\xb0\xd1\x82\xd0\xb5\xd0\xbb\xd1\x8c\xd0\
    \xbd\xd0\xbe\xd0\xbc\x20\xd0\xbd\xd0\xb0\xd0\xbf\xd1\x80\xd0\xb0\xd0\xb2\
    \xd0\xbb\xd0\xb5\xd0\xbd\xd0\xb8\xd0\xb8\x20\xd0\xbe\xd1\x81\xd0\xb8\x20\
    x)\n\n\x0c\n\x05\x05\x02\x02\x02\x01\x12\x03.\x04\x08\n\x0c\n\x05\x05\
    \x02\x02\x02\x02\x12\x03.\x0b\x0c\n[\n\x04\x05\x02\x02\x03\x12\x03/\x04\
    \x0e\"N\x20\xd0\x92\xd0\xbf\xd1\x80\xd0\xb0\xd0\xb2\xd0\xbe\x20(\xd0\xb2\
    \x20\xd0\xbf\xd0\xbe\xd0\xbb\xd0\xbe\xd0\xb6\xd0\xb8\xd1\x82\xd0\xb5\xd0\
    \xbb\xd1\x8c\xd0\xbd\xd0\xbe\xd0\xbc\x20\xd0\xbd\xd0\xb0\xd0\xbf\xd1\x80\
    \xd0\xb0\xd0\xb2\xd0\xbb\xd0\xb5\xd0\xbd\xd0\xb8\xd0\xb8\x20\xd0\xbe\xd1\
    \x81\xd0\xb8\x20x)\n\n\x0c\n\x05\x05\x02\x02\x03\x01\x12\x03/\x04\t\n\
    \x0c\n\x05\x05\x02\x02\x03\x02\x12\x03/\x0c\r\nI\n\x02\x04\x03\x12\x043\
    \0N\x01\x1a=\x20\xd0\xa2\xd0\xb5\xd0\xba\xd1\x83\xd1\x89\xd0\xb5\xd0\xb5\
    \x20\xd1\x81\xd0\xbe\xd1\x81\xd1\x82\xd0\xbe\xd1\x8f\xd0\xbd\xd0\xb8\xd0\
    \xb5\x20\xd0\xb8\xd0\xb3\xd1\x80\xd0\xbe\xd0\xb2\xd0\xbe\xd0\xb3\xd0\xbe\
    \x20\xd0\xbf\xd0\xbe\xd0\xbb\xd1\x8f\x20\n\n\n\x03\x04\x03\x01\x12\x033\
    \x08\x11\n\xcd\x02\n\x04\x04\x03\x03\0\x12\x047\x04:\x05\x1a\xbe\x02\x20\
    \xd0\x9a\xd0\xbe\xd0\xbe\xd1\x80\xd0\xb4\xd0\xb8\xd0\xbd\xd0\xb0\xd1\x82\
    \xd1\x8b\x20\xd0\xb2\x20\xd0\xbf\xd1\x80\xd0\xb5\xd0\xb4\xd0\xb5\xd0\xbb\
    \xd0\xb0\xd1\x85\x20\xd0\xb8\xd0\xb3\xd1\x80\xd0\xbe\xd0\xb2\xd0\xbe\xd0\
    \xb3\xd0\xbe\x20\xd0\xbf\xd0\xbe\xd0\xbb\xd1\x8f,\x20\xd0\xbb\xd0\xb8\
    \xd0\xb1\xd0\xbe\x20\xd0\xbe\xd1\x82\xd0\xbd\xd0\xbe\xd1\x81\xd0\xb8\xd1\
    \x82\xd0\xb5\xd0\xbb\xd1\x8c\xd0\xbd\xd0\xbe\xd0\xb5\x20\xd1\x81\xd0\xbc\
    \xd0\xb5\xd1\x89\xd0\xb5\xd0\xbd\xd0\xb8\xd0\xb5\x20\xd0\xba\xd0\xbe\xd0\
    \xbe\xd1\x80\xd0\xb4\xd0\xb8\xd0\xbd\xd0\xb0\xd1\x82.\n\x20\xd0\x9b\xd0\
    \xb5\xd0\xb2\xd0\xb0\xd1\x8f\x20\xd0\xb2\xd0\xb5\xd1\x80\xd1\x85\xd0\xbd\
    \xd1\x8f\xd1\x8f\x20\xd0\xba\xd0\xbb\xd0\xb5\xd1\x82\xd0\xba\xd0\xb0\x20\
    \xd0\xbf\xd0\xbe\xd0\xbb\xd1\x8f\x20\xd0\xb8\xd0\xbc\xd0\xb5\xd0\xb5\xd1\
    \x82\x20\xd0\xba\xd0\xbe\xd0\xbe\xd1\x80\xd0\xb4\xd0\xb8\xd0\xbd\xd0\xb0\
    \xd1\x82\xd1\x8b\x20(x=0,\x20y=0).\n\x20\xd0\x9d\xd0\xb0\xd0\xbf\xd1\x80\
    \xd0\xb0\xd0\xb2\xd0\xbb\xd0\xb5\xd0\xbd\xd0\xb8\xd0\xb5\x20\xd1\x81\xd0\
    \xbc\xd0\xb5\xd1\x89\xd0\xb5\xd0\xbd\xd0\xb8\xd1\x8f\x20\xd0\xb7\xd0\xb0\
    \xd0\xb4\xd0\xb0\xd1\x91\xd1\x82\xd1\x81\xd1\x8f\x20\xd0\xb7\xd0\xbd\xd0\
    \xb0\xd0\xba\xd0\xbe\xd0\xbc\x20\xd1\x87\xd0\xb8\xd1\x81\xd0\xb5\xd0\xbb\
    .\x20\n\x0c\n\x05\x04\x03\x03\0\x01\x12\x037\x0c\x11\n{\n\x06\x04\x03\
    \x03\0\x02\0\x12\x038\x08,\"l\x20\xd0\x9f\xd0\xbe\x20\xd0\xb3\xd0\xbe\
    \xd1\x80\xd0\xb8\xd0\xb7\xd0\xbe\xd0\xbd\xd1\x82\xd0\xb0\xd0\xbb\xd1\x8c\
    \xd0\xbd\xd0\xbe\xd0\xb9\x20\xd0\xbe\xd1\x81\xd0\xb8,\x20\xd0\xbf\xd0\
    \xbe\xd0\xbb\xd0\xbe\xd0\xb6\xd0\xb8\xd1\x82\xd0\xb5\xd0\xbb\xd1\x8c\xd0\
    \xbd\xd0\xbe\xd0\xb5\x20\xd0\xbd\xd0\xb0\xd0\xbf\xd1\x80\xd0\xb0\xd0\xb2\
    \xd0\xbb\xd0\xb5\xd0\xbd\xd0\xb8\xd0\xb5\x20-\x20\xd0\xb2\xd0\xbf\xd1\
    \x80\xd0\xb0\xd0\xb2\xd0\xbe\n\n\x0e\n\x07\x04\x03\x03\0\x02\0\x04\x12\
    \x038\x08\x10\n\x0e\n\x07\x04\x03\x03\0\x02\0\x05\x12\x038\x11\x17\n\x0e\
    \n\x07\x04\x03\x03\0\x02\0\x01\x12\x038\x18\x19\n\x0e\n\x07\x04\x03\x03\
    \0\x02\0\x03\x12\x038\x1c\x1d\n\x0e\n\x07\x04\x03\x03\0\x02\0\x08\x12\
    \x038\x1e+\n\x0e\n\x07\x04\x03\x03\0\x02\0\x07\x12\x038)*\ns\n\x06\x04\
    \x03\x03\0\x02\x01\x12\x039\x08,\"d\x20\xd0\x9f\xd0\xbe\x20\xd0\xb2\xd0\
    \xb5\xd1\x80\xd1\x82\xd0\xb8\xd0\xba\xd0\xb0\xd0\xbb\xd1\x8c\xd0\xbd\xd0\
    \xbe\xd0\xb9\x20\xd0\xbe\xd1\x81\xd0\xb8,\x20\xd0\xbf\xd0\xbe\xd0\xbb\
    \xd0\xbe\xd0\xb6\xd0\xb8\xd1\x82\xd0\xb5\xd0\xbb\xd1\x8c\xd0\xbd\xd0\xbe\
    \xd0\xb5\x20\xd0\xbd\xd0\xb0\xd0\xbf\xd1\x80\xd0\xb0\xd0\xb2\xd0\xbb\xd0\
    \xb5\xd0\xbd\xd0\xb8\xd0\xb5\x20-\x20\xd0\xb2\xd0\xbd\xd0\xb8\xd0\xb7\n\
    \n\x0e\n\x07\x04\x03\x03\0\x02\x01\x04\x12\x039\x08\x10\n\x0e\n\x07\x04\
    \x03\x03\0\x02\x01\x05\x12\x039\x11\x17\n\x0e\n\x07\x04\x03\x03\0\x02\
    \x01\x01\x12\x039\x18\x19\n\x0e\n\x07\x04\x03\x03\0\x02\x01\x03\x12\x039\
    \x1c\x1d\n\x0e\n\x07\x04\x03\x03\0\x02\x01\x08\x12\x039\x1e+\n\x0e\n\x07\
    \x04\x03\x03\0\x02\x01\x07\x12\x039)*\n\x18\n\x04\x04\x03\x03\x01\x12\
    \x04<\x04I\x05\x1a\n\x20\xd0\x97\xd0\xbc\xd0\xb5\xd1\x8f\n\n\x0c\n\x05\
    \x04\x03\x03\x01\x01\x12\x03<\x0c\x11\n3\n\x06\x04\x03\x03\x01\x04\0\x12\
    \x04>\x08A\t\x1a#\x20\xd0\xa1\xd1\x82\xd0\xb0\xd1\x82\xd1\x83\xd1\x81\
    \x20\xd0\xb7\xd0\xbc\xd0\xb5\xd0\xb8\x20\xd0\xb2\x20\xd0\xb8\xd0\xb3\xd1\
    \x80\xd0\xb5\n\n\x0e\n\x07\x04\x03\x03\x01\x04\0\x01\x12\x03>\r\x17\nA\n\
    \x08\x04\x03\x03\x01\x04\0\x02\0\x12\x03?\x0c\x16\"0\x20\xd0\x97\xd0\xbc\
    \xd0\xb5\xd1\x8f\x20\xd1\x83\xd0\xbf\xd1\x80\xd0\xb0\xd0\xb2\xd0\xbb\xd1\
    \x8f\xd0\xb5\xd1\x82\xd1\x81\xd1\x8f\x20\xd0\xb8\xd0\xb3\xd1\x80\xd0\xbe\
    \xd0\xba\xd0\xbe\xd0\xbc\n\n\x10\n\t\x04\x03\x03\x01\x04\0\x02\0\x01\x12\
    \x03?\x0c\x11\n\x10\n\t\x04\x03\x03\x01\x04\0\x02\0\x02\x12\x03?\x14\x15\
    \n\xba\x01\n\x08\x04\x03\x03\x01\x04\0\x02\x01\x12\x03@\x0c\x17\"\xa8\
    \x01\x20\xd0\x97\xd0\xbc\xd0\xb5\xd1\x8f\x20\xd0\xbf\xd1\x80\xd0\xb8\xd0\
    \xbd\xd0\xb0\xd0\xb4\xd0\xbb\xd0\xb5\xd0\xb6\xd0\xb0\xd0\xbb\xd0\xb0\x20\
    \xd0\xb8\xd0\xb3\xd1\x80\xd0\xbe\xd0\xba\xd1\x83,\x20\xd0\xba\xd0\xbe\
    \xd1\x82\xd0\xbe\xd1\x80\xd1\x8b\xd0\xb9\x20\xd0\xb2\xd1\x8b\xd1\x88\xd0\
    \xb5\xd0\xbb\x20\xd0\xb8\xd0\xb7\x20\xd0\xb8\xd0\xb3\xd1\x80\xd1\x8b,\
    \x20\xd0\xbe\xd0\xbd\xd0\xb0\x20\xd0\xbf\xd1\x80\xd0\xbe\xd0\xb4\xd0\xbe\
    \xd0\xbb\xd0\xb6\xd0\xb0\xd0\xb5\xd1\x82\x20\xd0\xb4\xd0\xb2\xd0\xb8\xd0\
    \xb6\xd0\xb5\xd0\xbd\xd0\xb8\xd0\xb5\x20\xd0\xba\xd1\x83\xd0\xb4\xd0\xb0\
    \x20\xd0\xb3\xd0\xbb\xd0\xb0\xd0\xb7\xd0\xb0\x20\xd0\xb3\xd0\xbb\xd1\x8f\
    \xd0\xb4\xd1\x8f\xd1\x82\n\n\x10\n\t\x04\x03\x03\x01\x04\0\x02\x01\x01\
    \x12\x03@\x0c\x12\n\x10\n\t\x04\x03\x03\x01\x04\0\x02\x01\x02\x12\x03@\
    \x15\x16\ni\n\x06\x04\x03\x03\x01\x02\0\x12\x03B\x08%\"Z\x20\xd0\x98\xd0\
    \xb4\xd0\xb5\xd0\xbd\xd1\x82\xd0\xb8\xd1\x84\xd0\xb8\xd0\xba\xd0\xb0\xd1\
    \x82\xd0\xbe\xd1\x80\x20\xd0\xb8\xd0\xb3\xd1\x80\xd0\xbe\xd0\xba\xd0\xb0\
    -\xd0\xb2\xd0\xbb\xd0\xb0\xd0\xb4\xd0\xb5\xd0\xbb\xd1\x8c\xd1\x86\xd0\
    \xb0\x20\xd0\xb7\xd0\xbc\xd0\xb5\xd0\xb8,\x20\xd1\x81\xd0\xbc.\x20GamePl\
    ayer.id\n\n\x0e\n\x07\x04\x03\x03\x01\x02\0\x04\x12\x03B\x08\x10\n\x0e\n\
    \x07\x04\x03\x03\x01\x02\0\x05\x12\x03B\x11\x16\n\x0e\n\x07\x04\x03\x03\
    \x01\x02\0\x01\x12\x03B\x17\x20\n\x0e\n\x07\x04\x03\x03\x01\x02\0\x03\
    \x12\x03B#$\n\xe1\x03\n\x06\x04\x03\x03\x01\x02\x01\x12\x03F\x08\"\x1a\
    \xd1\x03\x20\xd0\xa1\xd0\xbf\xd0\xb8\xd1\x81\xd0\xbe\xd0\xba\x20\"\xd0\
    \xba\xd0\xbb\xd1\x8e\xd1\x87\xd0\xb5\xd0\xb2\xd1\x8b\xd1\x85\"\x20\xd1\
    \x82\xd0\xbe\xd1\x87\xd0\xb5\xd0\xba\x20\xd0\xb7\xd0\xbc\xd0\xb5\xd0\xb8\
    .\x20\xd0\x9f\xd0\xb5\xd1\x80\xd0\xb2\xd0\xb0\xd1\x8f\x20\xd1\x82\xd0\
    \xbe\xd1\x87\xd0\xba\xd0\xb0\x20\xd1\x85\xd1\x80\xd0\xb0\xd0\xbd\xd0\xb8\
    \xd1\x82\x20\xd0\xba\xd0\xbe\xd0\xbe\xd1\x80\xd0\xb4\xd0\xb8\xd0\xbd\xd0\
    \xb0\xd1\x82\xd1\x8b\x20\xd0\xb3\xd0\xbe\xd0\xbb\xd0\xbe\xd0\xb2\xd1\x8b\
    \x20\xd0\xb7\xd0\xbc\xd0\xb5\xd0\xb8.\n\x20\xd0\x9a\xd0\xb0\xd0\xb6\xd0\
    \xb4\xd0\xb0\xd1\x8f\x20\xd1\x81\xd0\xbb\xd0\xb5\xd0\xb4\xd1\x83\xd1\x8e\
    \xd1\x89\xd0\xb0\xd1\x8f\x20-\x20\xd1\x81\xd0\xbc\xd0\xb5\xd1\x89\xd0\
    \xb5\xd0\xbd\xd0\xb8\xd0\xb5\x20\xd1\x81\xd0\xbb\xd0\xb5\xd0\xb4\xd1\x83\
    \xd1\x8e\xd1\x89\xd0\xb5\xd0\xb9\x20\"\xd0\xba\xd0\xbb\xd1\x8e\xd1\x87\
    \xd0\xb5\xd0\xb2\xd0\xbe\xd0\xb9\"\x20\xd1\x82\xd0\xbe\xd1\x87\xd0\xba\
    \xd0\xb8\x20\xd0\xbe\xd1\x82\xd0\xbd\xd0\xbe\xd1\x81\xd0\xb8\xd1\x82\xd0\
    \xb5\xd0\xbb\xd1\x8c\xd0\xbd\xd0\xbe\x20\xd0\xbf\xd1\x80\xd0\xb5\xd0\xb4\
    \xd1\x8b\xd0\xb4\xd1\x83\xd1\x89\xd0\xb5\xd0\xb9,\n\x20\xd0\xb2\x20\xd1\
    \x87\xd0\xb0\xd1\x81\xd1\x82\xd0\xbd\xd0\xbe\xd1\x81\xd1\x82\xd0\xb8\x20\
    \xd0\xbf\xd0\xbe\xd1\x81\xd0\xbb\xd0\xb5\xd0\xb4\xd0\xbd\xd1\x8f\xd1\x8f\
    \x20\xd1\x82\xd0\xbe\xd1\x87\xd0\xba\xd0\xb0\x20\xd1\x85\xd1\x80\xd0\xb0\
    \xd0\xbd\xd0\xb8\xd1\x82\x20\xd1\x81\xd0\xbc\xd0\xb5\xd1\x89\xd0\xb5\xd0\
    \xbd\xd0\xb8\xd0\xb5\x20\xd1\x85\xd0\xb2\xd0\xbe\xd1\x81\xd1\x82\xd0\xb0\
    \x20\xd0\xb7\xd0\xbc\xd0\xb5\xd0\xb8\x20\xd0\xbe\xd1\x82\xd0\xbd\xd0\xbe\
    \xd1\x81\xd0\xb8\xd1\x82\xd0\xb5\xd0\xbb\xd1\x8c\xd0\xbd\xd0\xbe\x20\xd0\
    \xbf\xd1\x80\xd0\xb5\xd0\xb4\xd1\x8b\xd0\xb4\xd1\x83\xd1\x89\xd0\xb5\xd0\
    \xb9\x20\"\xd0\xba\xd0\xbb\xd1\x8e\xd1\x87\xd0\xb5\xd0\xb2\xd0\xbe\xd0\
    \xb9\"\x20\xd1\x82\xd0\xbe\xd1\x87\xd0\xba\xd0\xb8.\x20\n\x0e\n\x07\x04\
    \x03\x03\x01\x02\x01\x04\x12\x03F\x08\x10\n\x0e\n\x07\x04\x03\x03\x01\
    \x02\x01\x06\x12\x03F\x11\x16\n\x0e\n\x07\x04\x03\x03\x01\x02\x01\x01\
    \x12\x03F\x17\x1d\n\x0e\n\x07\x04\x03\x03\x01\x02\x01\x03\x12\x03F\x20!\
    \n2\n\x06\x04\x03\x03\x01\x02\x02\x12\x03G\x088\"#\x20\xd1\x81\xd1\x82\
    \xd0\xb0\xd1\x82\xd1\x83\xd1\x81\x20\xd0\xb7\xd0\xbc\xd0\xb5\xd0\xb8\x20\
    \xd0\xb2\x20\xd0\xb8\xd0\xb3\xd1\x80\xd0\xb5\n\n\x0e\n\x07\x04\x03\x03\
    \x01\x02\x02\x04\x12\x03G\x08\x10\n\x0e\n\x07\x04\x03\x03\x01\x02\x02\
    \x06\x12\x03G\x11\x1b\n\x0e\n\x07\x04\x03\x03\x01\x02\x02\x01\x12\x03G\
    \x1c!\n\x0e\n\x07\x04\x03\x03\x01\x02\x02\x03\x12\x03G$%\n\x0e\n\x07\x04\
    \x03\x03\x01\x02\x02\x08\x12\x03G&7\n\x0e\n\x07\x04\x03\x03\x01\x02\x02\
    \x07\x12\x03G16\n\x88\x01\n\x06\x04\x03\x03\x01\x02\x03\x12\x03H\x08.\"y\
    \x20\xd0\x9d\xd0\xb0\xd0\xbf\xd1\x80\xd0\xb0\xd0\xb2\xd0\xbb\xd0\xb5\xd0\
    \xbd\xd0\xb8\xd0\xb5,\x20\xd0\xb2\x20\xd0\xba\xd0\xbe\xd1\x82\xd0\xbe\
    \xd1\x80\xd0\xbe\xd0\xbc\x20\"\xd0\xbf\xd0\xbe\xd0\xb2\xd1\x91\xd1\x80\
    \xd0\xbd\xd1\x83\xd1\x82\xd0\xb0\"\x20\xd0\xb3\xd0\xbe\xd0\xbb\xd0\xbe\
    \xd0\xb2\xd0\xb0\x20\xd0\xb7\xd0\xbc\xd0\xb5\xd0\xb9\xd0\xba\xd0\xb8\x20\
    \xd0\xb2\x20\xd1\x82\xd0\xb5\xd0\xba\xd1\x83\xd1\x89\xd0\xb8\xd0\xb9\x20\
    \xd0\xbc\xd0\xbe\xd0\xbc\xd0\xb5\xd0\xbd\xd1\x82\n\n\x0e\n\x07\x04\x03\
    \x03\x01\x02\x03\x04\x12\x03H\x08\x10\n\x0e\n\x07\x04\x03\x03\x01\x02\
    \x03\x06\x12\x03H\x11\x1a\n\x0e\n\x07\x04\x03\x03\x01\x02\x03\x01\x12\
    \x03H\x1b)\n\x0e\n\x07\x04\x03\x03\x01\x02\x03\x03\x12\x03H,-\n\x9a\x01\
    \n\x04\x04\x03\x02\0\x12\x03J\x04#\"\x8c\x01\x20\xd0\x9f\xd0\xbe\xd1\x80\
    \xd1\x8f\xd0\xb4\xd0\xba\xd0\xbe\xd0\xb2\xd1\x8b\xd0\xb9\x20\xd0\xbd\xd0\
    \xbe\xd0\xbc\xd0\xb5\xd1\x80\x20\xd1\x81\xd0\xbe\xd1\x81\xd1\x82\xd0\xbe\
    \xd1\x8f\xd0\xbd\xd0\xb8\xd1\x8f,\x20\xd1\x83\xd0\xbd\xd0\xb8\xd0\xba\
    \xd0\xb0\xd0\xbb\xd0\xb5\xd0\xbd\x20\xd0\xb2\x20\xd0\xbf\xd1\x80\xd0\xb5\
    \xd0\xb4\xd0\xb5\xd0\xbb\xd0\xb0\xd1\x85\x20\xd0\xb8\xd0\xb3\xd1\x80\xd1\
    \x8b,\x20\xd0\xbc\xd0\xbe\xd0\xbd\xd0\xbe\xd1\x82\xd0\xbe\xd0\xbd\xd0\
    \xbd\xd0\xbe\x20\xd0\xb2\xd0\xbe\xd0\xb7\xd1\x80\xd0\xb0\xd1\x81\xd1\x82\
    \xd0\xb0\xd0\xb5\xd1\x82\n\n\x0c\n\x05\x04\x03\x02\0\x04\x12\x03J\x04\
    \x0c\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03J\r\x12\n\x0c\n\x05\x04\x03\
    \x02\0\x01\x12\x03J\x13\x1e\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03J!\"\n$\
    \n\x04\x04\x03\x02\x01\x12\x03K\x04\x1e\"\x17\x20\xd0\xa1\xd0\xbf\xd0\
    \xb8\xd1\x81\xd0\xbe\xd0\xba\x20\xd0\xb7\xd0\xbc\xd0\xb5\xd0\xb9\n\n\x0c\
    \n\x05\x04\x03\x02\x01\x04\x12\x03K\x04\x0c\n\x0c\n\x05\x04\x03\x02\x01\
    \x06\x12\x03K\r\x12\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x03K\x13\x19\n\
    \x0c\n\x05\x04\x03\x02\x01\x03\x12\x03K\x1c\x1d\n4\n\x04\x04\x03\x02\x02\
    \x12\x03L\x04\x1d\"'\x20\xd0\xa1\xd0\xbf\xd0\xb8\xd1\x81\xd0\xbe\xd0\xba\
    \x20\xd0\xba\xd0\xbb\xd0\xb5\xd1\x82\xd0\xbe\xd0\xba\x20\xd1\x81\x20\xd0\
    \xb5\xd0\xb4\xd0\xbe\xd0\xb9\n\n\x0c\n\x05\x04\x03\x02\x02\x04\x12\x03L\
    \x04\x0c\n\x0c\n\x05\x04\x03\x02\x02\x06\x12\x03L\r\x12\n\x0c\n\x05\x04\
    \x03\x02\x02\x01\x12\x03L\x13\x18\n\x0c\n\x05\x04\x03\x02\x02\x03\x12\
    \x03L\x1b\x1c\nE\n\x04\x04\x03\x02\x03\x12\x03M\x04%\"8\x20\xd0\x90\xd0\
    \xba\xd1\x82\xd1\x83\xd0\xb0\xd0\xbb\xd1\x8c\xd0\xbd\xd0\xb5\xd0\xb9\xd1\
    \x88\xd0\xb8\xd0\xb9\x20\xd1\x81\xd0\xbf\xd0\xb8\xd1\x81\xd0\xbe\xd0\xba\
    \x20\xd0\xb8\xd0\xb3\xd1\x80\xd0\xbe\xd0\xba\xd0\xbe\xd0\xb2\n\n\x0c\n\
    \x05\x04\x03\x02\x03\x04\x12\x03M\x04\x0c\n\x0c\n\x05\x04\x03\x02\x03\
    \x06\x12\x03M\r\x18\n\x0c\n\x05\x04\x03\x02\x03\x01\x12\x03M\x19\x20\n\
    \x0c\n\x05\x04\x03\x02\x03\x03\x12\x03M#$\n\n\n\x02\x04\x04\x12\x04P\0U\
    \x01\n\n\n\x03\x04\x04\x01\x12\x03P\x08\x18\n*\n\x04\x04\x04\x02\0\x12\
    \x03Q\x04%\"\x1d\x20\xd0\xa2\xd0\xb5\xd0\xba\xd1\x83\xd1\x89\xd0\xb8\xd0\
    \xb5\x20\xd0\xb8\xd0\xb3\xd1\x80\xd0\xbe\xd0\xba\xd0\xb8\n\n\x0c\n\x05\
    \x04\x04\x02\0\x04\x12\x03Q\x04\x0c\n\x0c\n\x05\x04\x04\x02\0\x06\x12\
    \x03Q\r\x18\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03Q\x19\x20\n\x0c\n\x05\
    \x04\x04\x02\0\x03\x12\x03Q#$\n*\n\x04\x04\x04\x02\x01\x12\x03R\x04#\"\
    \x1d\x20\xd0\x9f\xd0\xb0\xd1\x80\xd0\xb0\xd0\xbc\xd0\xb5\xd1\x82\xd1\x80\
    \xd1\x8b\x20\xd0\xb8\xd0\xb3\xd1\x80\xd1\x8b\n\n\x0c\n\x05\x04\x04\x02\
    \x01\x04\x12\x03R\x04\x0c\n\x0c\n\x05\x04\x04\x02\x01\x06\x12\x03R\r\x17\
    \n\x0c\n\x05\x04\x04\x02\x01\x01\x12\x03R\x18\x1e\n\x0c\n\x05\x04\x04\
    \x02\x01\x03\x12\x03R!\"\n\x8a\x01\n\x04\x04\x04\x02\x02\x12\x03S\x040\"\
    }\x20\xd0\x9c\xd0\xbe\xd0\xb6\xd0\xbd\xd0\xbe\x20\xd0\xbb\xd0\xb8\x20\
    \xd0\xbd\xd0\xbe\xd0\xb2\xd0\xbe\xd0\xbc\xd1\x83\x20\xd0\xb8\xd0\xb3\xd1\
    \x80\xd0\xbe\xd0\xba\xd1\x83\x20\xd0\xbf\xd1\x80\xd0\xb8\xd1\x81\xd0\xbe\
    \xd0\xb5\xd0\xb4\xd0\xb8\xd0\xbd\xd0\xb8\xd1\x82\xd1\x8c\xd1\x81\xd1\x8f\
    \x20\xd0\xba\x20\xd0\xb8\xd0\xb3\xd1\x80\xd0\xb5\x20(\xd0\xb5\xd1\x81\
    \xd1\x82\xd1\x8c\x20\xd0\xbb\xd0\xb8\x20\xd0\xbc\xd0\xb5\xd1\x81\xd1\x82\
    \xd0\xbe\x20\xd0\xbd\xd0\xb0\x20\xd0\xbf\xd0\xbe\xd0\xbb\xd0\xb5)\n\n\
    \x0c\n\x05\x04\x04\x02\x02\x04\x12\x03S\x04\x0c\n\x0c\n\x05\x04\x04\x02\
    \x02\x05\x12\x03S\r\x11\n\x0c\n\x05\x04\x04\x02\x02\x01\x12\x03S\x12\x1a\
    \n\x0c\n\x05\x04\x04\x02\x02\x03\x12\x03S\x1d\x1e\n\x0c\n\x05\x04\x04\
    \x02\x02\x08\x12\x03S\x1f/\n\x0c\n\x05\x04\x04\x02\x02\x07\x12\x03S*.\nb\
    \n\x04\x04\x04\x02\x03\x12\x03T\x04\"\"U\x20\xd0\x93\xd0\xbb\xd0\xbe\xd0\
    \xb1\xd0\xb0\xd0\xbb\xd1\x8c\xd0\xbd\xd0\xbe\x20\xd1\x83\xd0\xbd\xd0\xb8\
    \xd0\xba\xd0\xb0\xd0\xbb\xd1\x8c\xd0\xbd\xd0\xbe\xd0\xb5\x20\xd0\xb8\xd0\
    \xbc\xd1\x8f\x20\xd0\xb8\xd0\xb3\xd1\x80\xd1\x8b,\x20\xd0\xbd\xd0\xb0\
    \xd0\xbf\xd1\x80\xd0\xb8\xd0\xbc\xd0\xb5\xd1\x80\x20\"my\x20game\"\n\n\
    \x0c\n\x05\x04\x04\x02\x03\x04\x12\x03T\x04\x0c\n\x0c\n\x05\x04\x04\x02\
    \x03\x05\x12\x03T\r\x13\n\x0c\n\x05\x04\x04\x02\x03\x01\x12\x03T\x14\x1d\
    \n\x0c\n\x05\x04\x04\x02\x03\x03\x12\x03T\x20!\nJ\n\x02\x04\x05\x12\x05X\
    \0\x93\x01\x01\x1a=\x20\xd0\x9e\xd0\xb1\xd1\x89\xd0\xb8\xd0\xb9\x20\xd1\
    \x84\xd0\xbe\xd1\x80\xd0\xbc\xd0\xb0\xd1\x82\x20\xd0\xbb\xd1\x8e\xd0\xb1\
    \xd0\xbe\xd0\xb3\xd0\xbe\x20UDP-\xd1\x81\xd0\xbe\xd0\xbe\xd0\xb1\xd1\x89\
    \xd0\xb5\xd0\xbd\xd0\xb8\xd1\x8f\n\n\n\n\x03\x04\x05\x01\x12\x03X\x08\
    \x13\na\n\x04\x04\x05\x03\0\x12\x04Z\x04[\x05\x1aS\x20\xd0\x9d\xd0\xb8\
    \xd1\x87\xd0\xb5\xd0\xb3\xd0\xbe\x20\xd0\xbd\xd0\xb5\x20\xd0\xbc\xd0\xb5\
    \xd0\xbd\xd1\x8f\xd0\xb5\xd0\xbc,\x20\xd0\xbf\xd1\x80\xd0\xbe\xd1\x81\
    \xd1\x82\xd0\xbe\x20\xd0\xb3\xd0\xbe\xd0\xb2\xd0\xbe\xd1\x80\xd0\xb8\xd0\
    \xbc,\x20\xd1\x87\xd1\x82\xd0\xbe\x20\xd0\xbc\xd1\x8b\x20\xd0\xb6\xd0\
    \xb8\xd0\xb2\xd1\x8b\n\n\x0c\n\x05\x04\x05\x03\0\x01\x12\x03Z\x0c\x13\nl\
    \n\x04\x04\x05\x03\x01\x12\x04]\x04_\x05\x1a^\x20\xd0\x9d\xd0\xb5-\xd1\
    \x86\xd0\xb5\xd0\xbd\xd1\x82\xd1\x80\xd0\xb0\xd0\xbb\xd1\x8c\xd0\xbd\xd1\
    \x8b\xd0\xb9\x20\xd0\xb8\xd0\xb3\xd1\x80\xd0\xbe\xd0\xba\x20\xd0\xbf\xd1\
    \x80\xd0\xbe\xd1\x81\xd0\xb8\xd1\x82\x20\xd0\xbf\xd0\xbe\xd0\xb2\xd0\xb5\
    \xd1\x80\xd0\xbd\xd1\x83\xd1\x82\xd1\x8c\x20\xd0\xb3\xd0\xbe\xd0\xbb\xd0\
    \xbe\xd0\xb2\xd1\x83\x20\xd0\xb7\xd0\xbc\xd0\xb5\xd0\xb8\n\n\x0c\n\x05\
    \x04\x05\x03\x01\x01\x12\x03]\x0c\x14\nM\n\x06\x04\x05\x03\x01\x02\0\x12\
    \x03^\x08)\">\x20\xd0\x9a\xd1\x83\xd0\xb4\xd0\xb0\x20\xd0\xbf\xd0\xbe\
    \xd0\xb2\xd0\xb5\xd1\x80\xd0\xbd\xd1\x83\xd1\x82\xd1\x8c\x20\xd0\xbd\xd0\
    \xb0\x20\xd1\x81\xd0\xbb\xd0\xb5\xd0\xb4\xd1\x83\xd1\x8e\xd1\x89\xd0\xb5\
    \xd0\xbc\x20\xd1\x88\xd0\xb0\xd0\xb3\xd0\xb5\n\n\x0e\n\x07\x04\x05\x03\
    \x01\x02\0\x04\x12\x03^\x08\x10\n\x0e\n\x07\x04\x05\x03\x01\x02\0\x06\
    \x12\x03^\x11\x1a\n\x0e\n\x07\x04\x05\x03\x01\x02\0\x01\x12\x03^\x1b$\n\
    \x0e\n\x07\x04\x05\x03\x01\x02\0\x03\x12\x03^'(\nT\n\x04\x04\x05\x03\x02\
    \x12\x04a\x04b\x05\x1aF\x20\xd0\x9f\xd0\xbe\xd0\xb4\xd1\x82\xd0\xb2\xd0\
    \xb5\xd1\x80\xd0\xb6\xd0\xb4\xd0\xb5\xd0\xbd\xd0\xb8\xd0\xb5\x20\xd1\x81\
    \xd0\xbe\xd0\xbe\xd0\xb1\xd1\x89\xd0\xb5\xd0\xbd\xd0\xb8\xd1\x8f\x20\xd1\
    \x81\x20\xd1\x82\xd0\xb0\xd0\xba\xd0\xb8\xd0\xbc\x20\xd0\xb6\xd0\xb5\x20\
    seq\n\n\x0c\n\x05\x04\x05\x03\x02\x01\x12\x03a\x0c\x12\n~\n\x04\x04\x05\
    \x03\x03\x12\x04d\x04f\x05\x1ap\x20\xd0\xa6\xd0\xb5\xd0\xbd\xd1\x82\xd1\
    \x80\xd0\xb0\xd0\xbb\xd1\x8c\xd0\xbd\xd1\x8b\xd0\xb9\x20\xd1\x83\xd0\xb7\
    \xd0\xb5\xd0\xbb\x20\xd1\x81\xd0\xbe\xd0\xbe\xd0\xb1\xd1\x89\xd0\xb0\xd0\
    \xb5\xd1\x82\x20\xd0\xbe\xd1\x81\xd1\x82\xd0\xb0\xd0\xbb\xd1\x8c\xd0\xbd\
    \xd1\x8b\xd0\xbc\x20\xd0\xb8\xd0\xb3\xd1\x80\xd0\xbe\xd0\xba\xd0\xb0\xd0\
    \xbc\x20\xd1\x81\xd0\xbe\xd1\x81\xd1\x82\xd0\xbe\xd1\x8f\xd0\xbd\xd0\xb8\
    \xd0\xb5\x20\xd0\xb8\xd0\xb3\xd1\x80\xd1\x8b\n\n\x0c\n\x05\x04\x05\x03\
    \x03\x01\x12\x03d\x0c\x14\n=\n\x06\x04\x05\x03\x03\x02\0\x12\x03e\x08%\"\
    .\x20\xd0\xa1\xd0\xbe\xd1\x81\xd1\x82\xd0\xbe\xd1\x8f\xd0\xbd\xd0\xb8\
    \xd0\xb5\x20\xd0\xb8\xd0\xb3\xd1\x80\xd0\xbe\xd0\xb2\xd0\xbe\xd0\xb3\xd0\
    \xbe\x20\xd0\xbf\xd0\xbe\xd0\xbb\xd1\x8f\n\n\x0e\n\x07\x04\x05\x03\x03\
    \x02\0\x04\x12\x03e\x08\x10\n\x0e\n\x07\x04\x05\x03\x03\x02\0\x06\x12\
    \x03e\x11\x1a\n\x0e\n\x07\x04\x05\x03\x03\x02\0\x01\x12\x03e\x1b\x20\n\
    \x0e\n\x07\x04\x05\x03\x03\x02\0\x03\x12\x03e#$\n\xa6\x01\n\x04\x04\x05\
    \x03\x04\x12\x04h\x04j\x05\x1a\x97\x01\x20\xd0\xa3\xd0\xb2\xd0\xb5\xd0\
    \xb4\xd0\xbe\xd0\xbc\xd0\xbb\xd0\xb5\xd0\xbd\xd0\xb8\xd0\xb5\x20\xd0\xbe\
    \xd0\xb1\x20\xd0\xb8\xd0\xb4\xd1\x83\xd1\x89\xd0\xb8\xd1\x85\x20\xd0\xb8\
    \xd0\xb3\xd1\x80\xd0\xb0\xd1\x85,\x20\xd1\x80\xd0\xb5\xd0\xb3\xd1\x83\
    \xd0\xbb\xd1\x8f\xd1\x80\xd0\xbd\xd0\xbe\x20\xd0\xbe\xd1\x82\xd0\xbf\xd1\
    \x80\xd0\xb0\xd0\xb2\xd0\xbb\xd1\x8f\xd0\xb5\xd1\x82\xd1\x81\xd1\x8f\x20\
    multicast-\xd0\xbe\xd0\xbc\x20\xd0\xb8\xd0\xbb\xd0\xb8\x20\xd0\xb2\x20\
    \xd0\xbe\xd1\x82\xd0\xb2\xd0\xb5\xd1\x82\x20\xd0\xbd\xd0\xb0\x20Discover\
    Msg\n\n\x0c\n\x05\x04\x05\x03\x04\x01\x12\x03h\x0c\x1b\n\x87\x01\n\x06\
    \x04\x05\x03\x04\x02\0\x12\x03i\x08,\"x\x20\xd0\x98\xd0\xb4\xd1\x83\xd1\
    \x89\xd0\xb8\xd0\xb5\x20\xd0\xb8\xd0\xb3\xd1\x80\xd1\x8b\x20(\xd0\xbd\
    \xd0\xb5\x20\xd0\xbc\xd0\xb5\xd0\xbd\xd0\xb5\xd0\xb5\x20\xd0\xbe\xd0\xb4\
    \xd0\xbd\xd0\xbe\xd0\xb9,\x20\xd0\xb0\x20\xd0\xbd\xd0\xb0\x20\xd1\x81\
    \xd0\xb5\xd1\x80\xd0\xb2\xd0\xb5\xd1\x80\xd0\xb5\x20\xd0\xb8\xd1\x85\x20\
    \xd0\xbc\xd0\xbe\xd0\xb6\xd0\xb5\xd1\x82\x20\xd0\xb1\xd1\x8b\xd1\x82\xd1\
    \x8c\x20\xd0\xbd\xd0\xb5\xd1\x81\xd0\xba\xd0\xbe\xd0\xbb\xd1\x8c\xd0\xba\
    \xd0\xbe)\n\n\x0e\n\x07\x04\x05\x03\x04\x02\0\x04\x12\x03i\x08\x10\n\x0e\
    \n\x07\x04\x05\x03\x04\x02\0\x06\x12\x03i\x11!\n\x0e\n\x07\x04\x05\x03\
    \x04\x02\0\x01\x12\x03i\"'\n\x0e\n\x07\x04\x05\x03\x04\x02\0\x03\x12\x03\
    i*+\nN\n\x04\x04\x05\x03\x05\x12\x04l\x04m\x05\x1a@\x20\xd0\x97\xd0\xb0\
    \xd0\xbf\xd1\x80\xd0\xbe\xd1\x81\x20\xd0\xb8\xd0\xbd\xd1\x84\xd0\xbe\xd1\
    \x80\xd0\xbc\xd0\xb0\xd1\x86\xd0\xb8\xd0\xb8\x20\xd0\xbe\xd0\xb1\x20\xd0\
    \xb8\xd0\xb4\xd1\x83\xd1\x89\xd0\xb8\xd1\x85\x20\xd0\xb8\xd0\xb3\xd1\x80\
    \xd0\xb0\xd1\x85\n\n\x0c\n\x05\x04\x05\x03\x05\x01\x12\x03l\x0c\x17\nf\n\
    \x04\x04\x05\x03\x06\x12\x04o\x04t\x05\x1aX\x20\xd0\x9d\xd0\xbe\xd0\xb2\
    \xd1\x8b\xd0\xb9\x20\xd0\xb8\xd0\xb3\xd1\x80\xd0\xbe\xd0\xba\x20\xd1\x85\
    \xd0\xbe\xd1\x87\xd0\xb5\xd1\x82\x20\xd0\xbf\xd1\x80\xd0\xb8\xd1\x81\xd0\
    \xbe\xd0\xb5\xd0\xb4\xd0\xb8\xd0\xbd\xd0\xb8\xd1\x82\xd1\x8c\xd1\x81\xd1\
    \x8f\x20\xd0\xba\x20\xd0\xb8\xd0\xb4\xd1\x83\xd1\x89\xd0\xb5\xd0\xb9\x20\
    \xd0\xb8\xd0\xb3\xd1\x80\xd0\xb5\n\n\x0c\n\x05\x04\x05\x03\x06\x01\x12\
    \x03o\x0c\x13\nG\n\x06\x04\x05\x03\x06\x02\0\x12\x03p\x08>\"8\x20\xd0\
    \xa2\xd0\xb8\xd0\xbf\x20\xd0\xbf\xd1\x80\xd0\xb8\xd1\x81\xd0\xbe\xd0\xb5\
    \xd0\xb4\xd0\xb8\xd0\xbd\xd1\x8f\xd1\x8e\xd1\x89\xd0\xb5\xd0\xb3\xd0\xbe\
    \xd1\x81\xd1\x8f\x20\xd0\xb8\xd0\xb3\xd1\x80\xd0\xbe\xd0\xba\xd0\xb0\n\n\
    \x0e\n\x07\x04\x05\x03\x06\x02\0\x04\x12\x03p\x08\x10\n\x0e\n\x07\x04\
    \x05\x03\x06\x02\0\x06\x12\x03p\x11\x1b\n\x0e\n\x07\x04\x05\x03\x06\x02\
    \0\x01\x12\x03p\x1c'\n\x0e\n\x07\x04\x05\x03\x06\x02\0\x03\x12\x03p*+\n\
    \x0e\n\x07\x04\x05\x03\x06\x02\0\x08\x12\x03p,=\n\x0e\n\x07\x04\x05\x03\
    \x06\x02\0\x07\x12\x03p7<\n$\n\x06\x04\x05\x03\x06\x02\x01\x12\x03q\x08(\
    \"\x15\x20\xd0\x98\xd0\xbc\xd1\x8f\x20\xd0\xb8\xd0\xb3\xd1\x80\xd0\xbe\
    \xd0\xba\xd0\xb0\n\n\x0e\n\x07\x04\x05\x03\x06\x02\x01\x04\x12\x03q\x08\
    \x10\n\x0e\n\x07\x04\x05\x03\x06\x02\x01\x05\x12\x03q\x11\x17\n\x0e\n\
    \x07\x04\x05\x03\x06\x02\x01\x01\x12\x03q\x18#\n\x0e\n\x07\x04\x05\x03\
    \x06\x02\x01\x03\x12\x03q&'\n\x83\x01\n\x06\x04\x05\x03\x06\x02\x02\x12\
    \x03r\x08&\"t\x20\xd0\x93\xd0\xbb\xd0\xbe\xd0\xb1\xd0\xb0\xd0\xbb\xd1\
    \x8c\xd0\xbd\xd0\xbe\x20\xd1\x83\xd0\xbd\xd0\xb8\xd0\xba\xd0\xb0\xd0\xbb\
    \xd1\x8c\xd0\xbd\xd0\xbe\xd0\xb5\x20\xd0\xb8\xd0\xbc\xd1\x8f\x20\xd0\xb8\
    \xd0\xb3\xd1\x80\xd1\x8b,\x20\xd0\xba\x20\xd0\xba\xd0\xbe\xd1\x82\xd0\
    \xbe\xd1\x80\xd0\xbe\xd0\xb9\x20\xd1\x85\xd0\xbe\xd1\x82\xd0\xb8\xd0\xbc\
    \x20\xd0\xbf\xd1\x80\xd0\xb8\xd1\x81\xd0\xbe\xd0\xb5\xd0\xb4\xd0\xb8\xd0\
    \xbd\xd0\xb8\xd1\x82\xd1\x8c\xd1\x81\xd1\x8f\n\n\x0e\n\x07\x04\x05\x03\
    \x06\x02\x02\x04\x12\x03r\x08\x10\n\x0e\n\x07\x04\x05\x03\x06\x02\x02\
    \x05\x12\x03r\x11\x17\n\x0e\n\x07\x04\x05\x03\x06\x02\x02\x01\x12\x03r\
    \x18!\n\x0e\n\x07\x04\x05\x03\x06\x02\x02\x03\x12\x03r$%\n\xb7\x01\n\x06\
    \x04\x05\x03\x06\x02\x03\x12\x03s\x08-\"\xa7\x01\x20NORMAL,\x20\xd0\xb5\
    \xd1\x81\xd0\xbb\xd0\xb8\x20\xd1\x85\xd0\xbe\xd1\x82\xd0\xb8\xd0\xbc\x20\
    \xd0\xb8\xd0\xb3\xd1\x80\xd0\xb0\xd1\x82\xd1\x8c;\x20VIEWER,\x20\xd0\xb5\
    \xd1\x81\xd0\xbb\xd0\xb8\x20\xd1\x85\xd0\xbe\xd1\x82\xd0\xb8\xd0\xbc\x20\
    \xd1\x82\xd0\xbe\xd0\xbb\xd1\x8c\xd0\xba\xd0\xbe\x20\xd0\xbf\xd0\xbe\xd0\
    \xbd\xd0\xb0\xd0\xb1\xd0\xbb\xd1\x8e\xd0\xb4\xd0\xb0\xd1\x82\xd1\x8c;\
    \x20\xd0\xbe\xd1\x81\xd1\x82\xd0\xb0\xd0\xbb\xd1\x8c\xd0\xbd\xd1\x8b\xd0\
    \xb5\x20\xd0\xb7\xd0\xbd\xd0\xb0\xd1\x87\xd0\xb5\xd0\xbd\xd0\xb8\xd1\x8f\
    \x20\xd0\xbd\xd0\xb5\xd0\xb4\xd0\xbe\xd0\xbf\xd1\x83\xd1\x81\xd1\x82\xd0\
    \xb8\xd0\xbc\xd1\x8b\n\n\x0e\n\x07\x04\x05\x03\x06\x02\x03\x04\x12\x03s\
    \x08\x10\n\x0e\n\x07\x04\x05\x03\x06\x02\x03\x06\x12\x03s\x11\x19\n\x0e\
    \n\x07\x04\x05\x03\x06\x02\x03\x01\x12\x03s\x1a(\n\x0e\n\x07\x04\x05\x03\
    \x06\x02\x03\x03\x12\x03s+,\n\x9e\x01\n\x04\x04\x05\x03\x07\x12\x04v\x04\
    x\x05\x1a\x8f\x01\x20\xd0\x9e\xd1\x88\xd0\xb8\xd0\xb1\xd0\xba\xd0\xb0\
    \x20\xd0\xbe\xd0\xbf\xd0\xb5\xd1\x80\xd0\xb0\xd1\x86\xd0\xb8\xd0\xb8\x20\
    (\xd0\xbd\xd0\xb0\xd0\xbf\xd1\x80\xd0\xb8\xd0\xbc\xd0\xb5\xd1\x80\x20\
    \xd0\xbe\xd1\x82\xd0\xba\xd0\xb0\xd0\xb7\x20\xd0\xb2\x20\xd0\xbf\xd1\x80\
    \xd0\xb8\xd1\x81\xd0\xbe\xd0\xb5\xd0\xb4\xd0\xb8\xd0\xbd\xd0\xb5\xd0\xbd\
    \xd0\xb8\xd0\xb8\x20\xd0\xba\x20\xd0\xb8\xd0\xb3\xd1\x80\xd0\xb5,\x20\
    \xd1\x82.\xd0\xba.\x20\xd0\xbd\xd0\xb5\xd1\x82\x20\xd0\xbc\xd0\xb5\xd1\
    \x81\xd1\x82\xd0\xb0\x20\xd0\xbd\xd0\xb0\x20\xd0\xbf\xd0\xbe\xd0\xbb\xd0\
    \xb5)\n\n\x0c\n\x05\x04\x05\x03\x07\x01\x12\x03v\x0c\x14\n\xa8\x01\n\x06\
    \x04\x05\x03\x07\x02\0\x12\x03w\x08*\"\x98\x01\x20\xd0\xa1\xd1\x82\xd1\
    \x80\xd0\xbe\xd0\xba\xd0\xbe\xd0\xb2\xd0\xbe\xd0\xb5\x20\xd1\x81\xd0\xbe\
    \xd0\xbe\xd0\xb1\xd1\x89\xd0\xb5\xd0\xbd\xd0\xb8\xd0\xb5,\x20\xd0\xbd\
    \xd1\x83\xd0\xb6\xd0\xbd\xd0\xbe\x20\xd0\xbe\xd1\x82\xd0\xbe\xd0\xb1\xd1\
    \x80\xd0\xb0\xd0\xb7\xd0\xb8\xd1\x82\xd1\x8c\x20\xd0\xb5\xd0\xb3\xd0\xbe\
    \x20\xd0\xbd\xd0\xb0\x20\xd1\x8d\xd0\xba\xd1\x80\xd0\xb0\xd0\xbd\xd0\xb5\
    ,\x20\xd0\xbd\xd0\xb5\x20\xd0\xb1\xd0\xbb\xd0\xbe\xd0\xba\xd0\xb8\xd1\
    \x80\xd1\x83\xd1\x8f\x20\xd1\x80\xd0\xb0\xd0\xb1\xd0\xbe\xd1\x82\xd1\x83\
    \x20\xd0\xbf\xd1\x80\xd0\xbe\xd0\xb3\xd1\x80\xd0\xb0\xd0\xbc\xd0\xbc\xd1\
    \x8b\n\n\x0e\n\x07\x04\x05\x03\x07\x02\0\x04\x12\x03w\x08\x10\n\x0e\n\
    \x07\x04\x05\x03\x07\x02\0\x05\x12\x03w\x11\x17\n\x0e\n\x07\x04\x05\x03\
    \x07\x02\0\x01\x12\x03w\x18%\n\x0e\n\x07\x04\x05\x03\x07\x02\0\x03\x12\
    \x03w()\n\xd2\x05\n\x04\x04\x05\x03\x08\x12\x06\x80\x01\x04\x83\x01\x05\
    \x1a\xc1\x05\x20\xd0\xa1\xd0\xbe\xd0\xbe\xd0\xb1\xd1\x89\xd0\xb5\xd0\xbd\
    \xd0\xb8\xd0\xb5\x20\xd0\xbe\x20\xd1\x81\xd0\xbc\xd0\xb5\xd0\xbd\xd0\xb5\
    \x20\xd1\x80\xd0\xbe\xd0\xbb\xd0\xb8:\n\x201.\x20\xd0\xbe\xd1\x82\x20\
    \xd0\xb7\xd0\xb0\xd0\xbc\xd0\xb5\xd1\x81\xd1\x82\xd0\xb8\xd1\x82\xd0\xb5\
    \xd0\xbb\xd1\x8f\x20\xd0\xb4\xd1\x80\xd1\x83\xd0\xb3\xd0\xb8\xd0\xbc\x20\
    \xd0\xb8\xd0\xb3\xd1\x80\xd0\xbe\xd0\xba\xd0\xb0\xd0\xbc\x20\xd0\xbe\x20\
    \xd1\x82\xd0\xbe\xd0\xbc,\x20\xd1\x87\xd1\x82\xd0\xbe\x20\xd0\xbf\xd0\
    \xbe\xd1\x80\xd0\xb0\x20\xd0\xbd\xd0\xb0\xd1\x87\xd0\xb8\xd0\xbd\xd0\xb0\
    \xd1\x82\xd1\x8c\x20\xd1\x81\xd1\x87\xd0\xb8\xd1\x82\xd0\xb0\xd1\x82\xd1\
    \x8c\x20\xd0\xb5\xd0\xb3\xd0\xbe\x20\xd0\xb3\xd0\xbb\xd0\xb0\xd0\xb2\xd0\
    \xbd\xd1\x8b\xd0\xbc\x20(sender_role\x20=\x20MASTER)\n\x202.\x20\xd0\xbe\
    \xd1\x82\x20\xd0\xbe\xd1\x81\xd0\xbe\xd0\xb7\xd0\xbd\xd0\xb0\xd0\xbd\xd0\
    \xbd\xd0\xbe\x20\xd0\xb2\xd1\x8b\xd1\x85\xd0\xbe\xd0\xb4\xd1\x8f\xd1\x89\
    \xd0\xb5\xd0\xb3\xd0\xbe\x20\xd0\xb8\xd0\xb3\xd1\x80\xd0\xbe\xd0\xba\xd0\
    \xb0\x20(sender_role\x20=\x20VIEWER)\n\x203.\x20\xd0\xbe\xd1\x82\x20\xd0\
    \xb3\xd0\xbb\xd0\xb0\xd0\xb2\xd0\xbd\xd0\xbe\xd0\xb3\xd0\xbe\x20\xd0\xba\
    \x20\xd1\x83\xd0\xbc\xd0\xb5\xd1\x80\xd1\x88\xd0\xb5\xd0\xbc\xd1\x83\x20\
    \xd0\xb8\xd0\xb3\xd1\x80\xd0\xbe\xd0\xba\xd1\x83\x20(receiver_role\x20=\
    \x20VIEWER)\n\x204.\x20\xd0\xb2\x20\xd0\xba\xd0\xbe\xd0\xbc\xd0\xb1\xd0\
    \xb8\xd0\xbd\xd0\xb0\xd1\x86\xd0\xb8\xd0\xb8\x20\xd1\x81\x201,2\x20\xd0\
    \xb8\xd0\xbb\xd0\xb8\x20\xd0\xbe\xd1\x82\xd0\xb4\xd0\xb5\xd0\xbb\xd1\x8c\
    \xd0\xbd\xd0\xbe\x20\xd0\xbe\xd1\x82\x20\xd0\xbd\xd0\xb8\xd1\x85:\x20\
    \xd0\xbd\xd0\xb0\xd0\xb7\xd0\xbd\xd0\xb0\xd1\x87\xd0\xb5\xd0\xbd\xd0\xb8\
    \xd0\xb5\x20\xd0\xba\xd0\xbe\xd0\xb3\xd0\xbe-\xd1\x82\xd0\xbe\x20\xd0\
    \xb7\xd0\xb0\xd0\xbc\xd0\xb5\xd1\x81\xd1\x82\xd0\xb8\xd1\x82\xd0\xb5\xd0\
    \xbb\xd0\xb5\xd0\xbc\x20(receiver_role\x20=\x20DEPUTY)\n\x205.\x20\xd0\
    \xb2\x20\xd0\xba\xd0\xbe\xd0\xbc\xd0\xb1\xd0\xb8\xd0\xbd\xd0\xb0\xd1\x86\
    \xd0\xb8\xd0\xb8\x20\xd1\x81\x202\x20\xd0\xbe\xd1\x82\x20\xd0\xb3\xd0\
    \xbb\xd0\xb0\xd0\xb2\xd0\xbd\xd0\xbe\xd0\xb3\xd0\xbe\x20\xd1\x83\xd0\xb7\
    \xd0\xbb\xd0\xb0\x20\xd0\xb7\xd0\xb0\xd0\xbc\xd0\xb5\xd1\x81\xd1\x82\xd0\
    \xb8\xd1\x82\xd0\xb5\xd0\xbb\xd1\x8e\x20\xd0\xbe\x20\xd1\x82\xd0\xbe\xd0\
    \xbc,\x20\xd1\x87\xd1\x82\xd0\xbe\x20\xd0\xbe\xd0\xbd\x20\xd1\x81\xd1\
    \x82\xd0\xb0\xd0\xbd\xd0\xbe\xd0\xb2\xd0\xb8\xd1\x82\xd1\x81\xd1\x8f\x20\
    \xd0\xb3\xd0\xbb\xd0\xb0\xd0\xb2\xd0\xbd\xd1\x8b\xd0\xbc\x20(receiver_ro\
    le\x20=\x20MASTER)\n\n\r\n\x05\x04\x05\x03\x08\x01\x12\x04\x80\x01\x0c\
    \x19\n\x0e\n\x06\x04\x05\x03\x08\x02\0\x12\x04\x81\x01\x08*\n\x0f\n\x07\
    \x04\x05\x03\x08\x02\0\x04\x12\x04\x81\x01\x08\x10\n\x0f\n\x07\x04\x05\
    \x03\x08\x02\0\x06\x12\x04\x81\x01\x11\x19\n\x0f\n\x07\x04\x05\x03\x08\
    \x02\0\x01\x12\x04\x81\x01\x1a%\n\x0f\n\x07\x04\x05\x03\x08\x02\0\x03\
    \x12\x04\x81\x01()\n\x0e\n\x06\x04\x05\x03\x08\x02\x01\x12\x04\x82\x01\
    \x08,\n\x0f\n\x07\x04\x05\x03\x08\x02\x01\x04\x12\x04\x82\x01\x08\x10\n\
    \x0f\n\x07\x04\x05\x03\x08\x02\x01\x06\x12\x04\x82\x01\x11\x19\n\x0f\n\
    \x07\x04\x05\x03\x08\x02\x01\x01\x12\x04\x82\x01\x1a'\n\x0f\n\x07\x04\
    \x05\x03\x08\x02\x01\x03\x12\x04\x82\x01*+\n\xb9\x01\n\x04\x04\x05\x02\0\
    \x12\x04\x84\x01\x04\x1f\"\xaa\x01\x20\xd0\x9f\xd0\xbe\xd1\x80\xd1\x8f\
    \xd0\xb4\xd0\xba\xd0\xbe\xd0\xb2\xd1\x8b\xd0\xb9\x20\xd0\xbd\xd0\xbe\xd0\
    \xbc\xd0\xb5\xd1\x80\x20\xd1\x81\xd0\xbe\xd0\xbe\xd0\xb1\xd1\x89\xd0\xb5\
    \xd0\xbd\xd0\xb8\xd1\x8f,\x20\xd1\x83\xd0\xbd\xd0\xb8\xd0\xba\xd0\xb0\
    \xd0\xbb\xd0\xb5\xd0\xbd\x20\xd0\xb4\xd0\xbb\xd1\x8f\x20\xd0\xbe\xd1\x82\
    \xd0\xbf\xd1\x80\xd0\xb0\xd0\xb2\xd0\xb8\xd1\x82\xd0\xb5\xd0\xbb\xd1\x8f\
    \x20\xd0\xb2\x20\xd0\xbf\xd1\x80\xd0\xb5\xd0\xb4\xd0\xb5\xd0\xbb\xd0\xb0\
    \xd1\x85\x20\xd0\xb8\xd0\xb3\xd1\x80\xd1\x8b,\x20\xd0\xbc\xd0\xbe\xd0\
    \xbd\xd0\xbe\xd1\x82\xd0\xbe\xd0\xbd\xd0\xbd\xd0\xbe\x20\xd0\xb2\xd0\xbe\
    \xd0\xb7\xd1\x80\xd0\xb0\xd1\x81\xd1\x82\xd0\xb0\xd0\xb5\xd1\x82\n\n\r\n\
    \x05\x04\x05\x02\0\x04\x12\x04\x84\x01\x04\x0c\n\r\n\x05\x04\x05\x02\0\
    \x05\x12\x04\x84\x01\r\x12\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\x84\x01\
    \x13\x1a\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\x84\x01\x1d\x1e\n\x8c\x01\n\
    \x04\x04\x05\x02\x01\x12\x04\x85\x01\x04\"\"~\x20ID\x20\xd0\xb8\xd0\xb3\
    \xd1\x80\xd0\xbe\xd0\xba\xd0\xb0-\xd0\xbe\xd1\x82\xd0\xbf\xd1\x80\xd0\
    \xb0\xd0\xb2\xd0\xb8\xd1\x82\xd0\xb5\xd0\xbb\xd1\x8f\x20\xd1\x8d\xd1\x82\
    \xd0\xbe\xd0\xb3\xd0\xbe\x20\xd1\x81\xd0\xbe\xd0\xbe\xd0\xb1\xd1\x89\xd0\
    \xb5\xd0\xbd\xd0\xb8\xd1\x8f\x20(\xd0\xbe\xd0\xb1\xd1\x8f\xd0\xb7\xd0\
    \xb0\xd1\x82\xd0\xb5\xd0\xbb\xd1\x8c\xd0\xbd\xd0\xbe\x20\xd0\xb4\xd0\xbb\
    \xd1\x8f\x20AckMsg\x20\xd0\xb8\x20RoleChangeMsg)\n\n\r\n\x05\x04\x05\x02\
    \x01\x04\x12\x04\x85\x01\x04\x0c\n\r\n\x05\x04\x05\x02\x01\x05\x12\x04\
    \x85\x01\r\x12\n\r\n\x05\x04\x05\x02\x01\x01\x12\x04\x85\x01\x13\x1c\n\r\
    \n\x05\x04\x05\x02\x01\x03\x12\x04\x85\x01\x1f!\n\x8a\x01\n\x04\x04\x05\
    \x02\x02\x12\x04\x86\x01\x04$\"|\x20ID\x20\xd0\xb8\xd0\xb3\xd1\x80\xd0\
    \xbe\xd0\xba\xd0\xb0-\xd0\xbf\xd0\xbe\xd0\xbb\xd1\x83\xd1\x87\xd0\xb0\
    \xd1\x82\xd0\xb5\xd0\xbb\xd1\x8f\x20\xd1\x8d\xd1\x82\xd0\xbe\xd0\xb3\xd0\
    \xbe\x20\xd1\x81\xd0\xbe\xd0\xbe\xd0\xb1\xd1\x89\xd0\xb5\xd0\xbd\xd0\xb8\
    \xd1\x8f\x20(\xd0\xbe\xd0\xb1\xd1\x8f\xd0\xb7\xd0\xb0\xd1\x82\xd0\xb5\
    \xd0\xbb\xd1\x8c\xd0\xbd\xd0\xbe\x20\xd0\xb4\xd0\xbb\xd1\x8f\x20AckMsg\
    \x20\xd0\xb8\x20RoleChangeMsg)\n\n\r\n\x05\x04\x05\x02\x02\x04\x12\x04\
    \x86\x01\x04\x0c\n\r\n\x05\x04\x05\x02\x02\x05\x12\x04\x86\x01\r\x12\n\r\
    \n\x05\x04\x05\x02\x02\x01\x12\x04\x86\x01\x13\x1e\n\r\n\x05\x04\x05\x02\
    \x02\x03\x12\x04\x86\x01!#\n+\n\x04\x04\x05\x08\0\x12\x06\x88\x01\x04\
    \x92\x01\x05\x1a\x1b\x20\xd0\xa2\xd0\xb8\xd0\xbf\x20\xd1\x81\xd0\xbe\xd0\
    \xbe\xd0\xb1\xd1\x89\xd0\xb5\xd0\xbd\xd0\xb8\xd1\x8f\n\n\r\n\x05\x04\x05\
    \x08\0\x01\x12\x04\x88\x01\n\x0e\n\x0c\n\x04\x04\x05\x02\x03\x12\x04\x89\
    \x01\x08\x19\n\r\n\x05\x04\x05\x02\x03\x06\x12\x04\x89\x01\x08\x0f\n\r\n\
    \x05\x04\x05\x02\x03\x01\x12\x04\x89\x01\x10\x14\n\r\n\x05\x04\x05\x02\
    \x03\x03\x12\x04\x89\x01\x17\x18\n\x0c\n\x04\x04\x05\x02\x04\x12\x04\x8a\
    \x01\x08\x1b\n\r\n\x05\x04\x05\x02\x04\x06\x12\x04\x8a\x01\x08\x10\n\r\n\
    \x05\x04\x05\x02\x04\x01\x12\x04\x8a\x01\x11\x16\n\r\n\x05\x04\x05\x02\
    \x04\x03\x12\x04\x8a\x01\x19\x1a\n\x0c\n\x04\x04\x05\x02\x05\x12\x04\x8b\
    \x01\x08\x17\n\r\n\x05\x04\x05\x02\x05\x06\x12\x04\x8b\x01\x08\x0e\n\r\n\
    \x05\x04\x05\x02\x05\x01\x12\x04\x8b\x01\x0f\x12\n\r\n\x05\x04\x05\x02\
    \x05\x03\x12\x04\x8b\x01\x15\x16\n\x0c\n\x04\x04\x05\x02\x06\x12\x04\x8c\
    \x01\x08\x1b\n\r\n\x05\x04\x05\x02\x06\x06\x12\x04\x8c\x01\x08\x10\n\r\n\
    \x05\x04\x05\x02\x06\x01\x12\x04\x8c\x01\x11\x16\n\r\n\x05\x04\x05\x02\
    \x06\x03\x12\x04\x8c\x01\x19\x1a\n\x0c\n\x04\x04\x05\x02\x07\x12\x04\x8d\
    \x01\x08)\n\r\n\x05\x04\x05\x02\x07\x06\x12\x04\x8d\x01\x08\x17\n\r\n\
    \x05\x04\x05\x02\x07\x01\x12\x04\x8d\x01\x18$\n\r\n\x05\x04\x05\x02\x07\
    \x03\x12\x04\x8d\x01'(\n\x0c\n\x04\x04\x05\x02\x08\x12\x04\x8e\x01\x08\
    \x19\n\r\n\x05\x04\x05\x02\x08\x06\x12\x04\x8e\x01\x08\x0f\n\r\n\x05\x04\
    \x05\x02\x08\x01\x12\x04\x8e\x01\x10\x14\n\r\n\x05\x04\x05\x02\x08\x03\
    \x12\x04\x8e\x01\x17\x18\n\x0c\n\x04\x04\x05\x02\t\x12\x04\x8f\x01\x08\
    \x1b\n\r\n\x05\x04\x05\x02\t\x06\x12\x04\x8f\x01\x08\x10\n\r\n\x05\x04\
    \x05\x02\t\x01\x12\x04\x8f\x01\x11\x16\n\r\n\x05\x04\x05\x02\t\x03\x12\
    \x04\x8f\x01\x19\x1a\n\x0c\n\x04\x04\x05\x02\n\x12\x04\x90\x01\x08&\n\r\
    \n\x05\x04\x05\x02\n\x06\x12\x04\x90\x01\x08\x15\n\r\n\x05\x04\x05\x02\n\
    \x01\x12\x04\x90\x01\x16!\n\r\n\x05\x04\x05\x02\n\x03\x12\x04\x90\x01$%\
    \n\x0c\n\x04\x04\x05\x02\x0b\x12\x04\x91\x01\x08\"\n\r\n\x05\x04\x05\x02\
    \x0b\x06\x12\x04\x91\x01\x08\x13\n\r\n\x05\x04\x05\x02\x0b\x01\x12\x04\
    \x91\x01\x14\x1c\n\r\n\x05\x04\x05\x02\x0b\x03\x12\x04\x91\x01\x1f!\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(17);
            messages.push(GamePlayer::generated_message_descriptor_data());
            messages.push(GameConfig::generated_message_descriptor_data());
            messages.push(GamePlayers::generated_message_descriptor_data());
            messages.push(GameState::generated_message_descriptor_data());
            messages.push(GameAnnouncement::generated_message_descriptor_data());
            messages.push(GameMessage::generated_message_descriptor_data());
            messages.push(game_state::Coord::generated_message_descriptor_data());
            messages.push(game_state::Snake::generated_message_descriptor_data());
            messages.push(game_message::PingMsg::generated_message_descriptor_data());
            messages.push(game_message::SteerMsg::generated_message_descriptor_data());
            messages.push(game_message::AckMsg::generated_message_descriptor_data());
            messages.push(game_message::StateMsg::generated_message_descriptor_data());
            messages.push(game_message::AnnouncementMsg::generated_message_descriptor_data());
            messages.push(game_message::DiscoverMsg::generated_message_descriptor_data());
            messages.push(game_message::JoinMsg::generated_message_descriptor_data());
            messages.push(game_message::ErrorMsg::generated_message_descriptor_data());
            messages.push(game_message::RoleChangeMsg::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(4);
            enums.push(NodeRole::generated_enum_descriptor_data());
            enums.push(PlayerType::generated_enum_descriptor_data());
            enums.push(Direction::generated_enum_descriptor_data());
            enums.push(game_state::snake::SnakeState::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
